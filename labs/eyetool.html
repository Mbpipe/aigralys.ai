<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Medidor √ìptico Facial ‚Äî Gu√≠a CR80 + OpenCV/MediaPipe</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- OpenCV opcional (si no carga, seguimos con edge match simple) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- MediaPipe Face Mesh: lo cargo on-demand desde JS -->
  <style>
    html,body{background:#eef2ff}
    #video{
      width:100%;height:auto;max-height:68vh;object-fit:cover;background:#000;border-radius:1rem;
      transform:scaleX(-1); /* espejo solo para vista previa */
    }
    #overlay{
      position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;
    }
    .tag{font-variant-numeric:tabular-nums}
  </style>
</head>
<body>
  <div class="min-h-screen p-4">
    <div class="max-w-3xl mx-auto space-y-4">
      <!-- Header -->
      <div class="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-500">
        <div class="flex items-center justify-between">
          <div>
            <h1 class="text-3xl font-bold">Medidor √ìptico Facial</h1>
            <p class="text-slate-600">C√°mara + Gu√≠a CR80 + IPD</p>
          </div>
          <div class="text-xs bg-slate-100 px-3 py-1 rounded" id="envBadge">secure:‚Äî ‚Ä¢ media:‚Äî</div>
        </div>
        <div class="text-sm text-slate-500 mt-2" id="stateText">estado: idle</div>
      </div>

      <!-- Captura -->
      <div class="bg-white rounded-2xl shadow p-5">
        <h2 class="text-xl font-semibold mb-3">Captura de Imagen</h2>
        <div class="grid grid-cols-2 gap-3">
          <label class="inline-flex items-center justify-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 rounded-xl cursor-pointer">
            üñºÔ∏è <span>Subir Foto</span>
            <input id="file" type="file" class="hidden" accept="image/*"/>
          </label>
          <button id="btnCam" class="inline-flex items-center justify-center gap-2 bg-violet-600 hover:bg-violet-700 text-white font-semibold py-3 rounded-xl">üì∑ C√°mara</button>
        </div>

        <div class="mt-4 relative" id="camBox" style="display:none">
          <video id="video" playsinline autoplay muted></video>
          <canvas id="overlay"></canvas>
          <!-- Canvas oculto para an√°lisis de ROI (no se muestra) -->
          <canvas id="frame" class="hidden"></canvas>

          <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3 items-center">
            <div class="flex items-center gap-3">
              <label class="inline-flex items-center gap-2">
                <input id="useGuide" type="checkbox" class="scale-110" checked>
                <span>Usar Gu√≠a CR80</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input id="autoCap" type="checkbox" class="scale-110" checked>
                <span>Auto-capturar (‚â•70%)</span>
              </label>
            </div>
            <div class="flex items-center gap-3 sm:justify-end">
              <button id="btnCapture" class="flex-1 sm:flex-none inline-flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-3 rounded-xl">üì∏ Capturar</button>
              <button id="btnStop" class="inline-flex items-center justify-center gap-2 bg-rose-600 hover:bg-rose-700 text-white font-semibold px-4 py-3 rounded-xl">üõë Cerrar</button>
            </div>
          </div>

          <div id="guideControls" class="mt-3 flex flex-wrap items-center gap-3">
            <div class="flex-1 min-w-[220px]">
              <input id="guideSlider" type="range" min="140" max="420" value="260" class="w-full"/>
              <div class="text-xs text-slate-600">
                Ancho gu√≠a: <span class="tag" id="guideW">260</span> px ‚Ä¢ Alto: <span class="tag" id="guideH">164</span> px
              </div>
            </div>
            <div class="px-3 py-2 rounded bg-slate-100 text-sm">
              Match: <b class="tag" id="matchPct">0%</b> ‚Ä¢ OpenCV: <b class="tag" id="ocvPct">0%</b>
            </div>
          </div>
        </div>
      </div>

      <!-- Imagen + Procesar -->
      <div id="imgCard" class="bg-white rounded-2xl shadow p-5" style="display:none">
        <h3 class="font-semibold mb-3">Imagen Capturada</h3>
        <img id="img" class="w-full rounded-lg shadow" alt="captura"/>
        <div class="mt-3">
          <button id="btnProcess" class="inline-flex items-center justify-center gap-2 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold px-4 py-3 rounded-xl">üßÆ Procesar</button>
          <span class="text-sm text-slate-600 ml-3" id="procStep"></span>
        </div>
      </div>

      <!-- Resultado -->
      <div id="resCard" class="bg-white rounded-2xl shadow p-5 space-y-3" style="display:none">
        <div class="flex items-center justify-between">
          <h3 class="font-semibold">Resultado</h3>
          <span class="text-xs px-2 py-1 rounded bg-slate-100" id="methodBadge">‚Äî</span>
        </div>
        <div class="grid grid-cols-2 gap-3">
          <div class="p-3 rounded bg-indigo-50">
            <div class="text-xs text-slate-600">IPD</div>
            <div class="text-2xl font-bold" id="ipdVal">‚Äî</div>
          </div>
          <div class="p-3 rounded bg-violet-50">
            <div class="text-xs text-slate-600">Escala (px/mm)</div>
            <div class="text-xl font-semibold tag" id="pxmm">‚Äî</div>
            <div class="text-xs text-slate-500" id="scaleFrom">‚Äî</div>
          </div>
        </div>
        <div class="mt-2">
          <h4 class="font-semibold mb-2">Imagen Anotada</h4>
          <img id="annot" class="w-full rounded-lg shadow" alt="anotada"/>
          <a id="annotDl" class="inline-block mt-3 px-3 py-2 rounded bg-blue-600 text-white">Descargar PNG</a>
        </div>
      </div>

      <div class="text-center text-xs text-slate-500 py-4">¬© 2025 ‚Äî C√°mara + Gu√≠a CR80 + OpenCV + MediaPipe</div>
    </div>
  </div>

<script>
(() => {
  const CR80_W=85.60, CR80_H=53.98, CR80_AR=CR80_W/CR80_H;

  // UI refs
  const envBadge = document.getElementById('envBadge');
  const stateText= document.getElementById('stateText');
  const fileInput= document.getElementById('file');
  const btnCam   = document.getElementById('btnCam');
  const btnStop  = document.getElementById('btnStop');
  const btnCapture = document.getElementById('btnCapture');
  const camBox   = document.getElementById('camBox');
  const video    = document.getElementById('video');
  const overlay  = document.getElementById('overlay');
  const frameCv  = document.getElementById('frame');
  const useGuide = document.getElementById('useGuide');
  const autoCap  = document.getElementById('autoCap');
  const slider   = document.getElementById('guideSlider');
  const guideWEl = document.getElementById('guideW');
  const guideHEl = document.getElementById('guideH');
  const matchPct = document.getElementById('matchPct');
  const ocvPct   = document.getElementById('ocvPct');

  const imgCard  = document.getElementById('imgCard');
  const imgEl    = document.getElementById('img');
  const btnProcess = document.getElementById('btnProcess');
  const procStep = document.getElementById('procStep');

  const resCard  = document.getElementById('resCard');
  const methodBadge = document.getElementById('methodBadge');
  const ipdVal   = document.getElementById('ipdVal');
  const pxmm     = document.getElementById('pxmm');
  const scaleFrom= document.getElementById('scaleFrom');
  const annotImg = document.getElementById('annot');
  const annotDl  = document.getElementById('annotDl');

  // Status
  const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
  const mediaOk  = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
  envBadge.textContent = `secure:${isSecure} ‚Ä¢ media:${mediaOk}`;
  stateText.textContent = 'estado: idle';
  let stream=null, raf=0;

  // FaceMesh (opcional)
  let faceMesh=null;
  function loadFaceMesh(){
    return new Promise((resolve)=>{
      if(window.FaceMesh){ faceMesh = new window.FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
        faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5});
        resolve(); return;
      }
      const s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
      s.async=true;
      s.onload=()=>{ faceMesh = new window.FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
        faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5});
        resolve(); };
      s.onerror=()=>resolve();
      document.body.appendChild(s);
    });
  }
  loadFaceMesh();

  // Camera
  async function startCamera(){
    if(!mediaOk){ alert('Este navegador no permite c√°mara.'); return; }
    stateText.textContent = 'estado: solicitando c√°mara‚Ä¶';
    try{
      video.setAttribute('playsinline',''); video.muted = true; video.playsInline = true;
      stream = await navigator.mediaDevices.getUserMedia({
        video:{facingMode:{ideal:'user'},width:{ideal:1280},height:{ideal:720}}, audio:false
      });
      video.srcObject = stream;
      await video.play().catch(()=>{});
      camBox.style.display = '';
      stateText.textContent = 'estado: ready';
      startOverlayLoop();
    }catch(e){
      stateText.textContent = 'estado: error ‚Äî '+e.message;
      console.error(e);
    }
  }
  function stopCamera(){
    cancelAnimationFrame(raf); raf=0;
    if(video){ video.pause(); video.srcObject=null; }
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    camBox.style.display = 'none';
    stateText.textContent = 'estado: idle';
  }

  // Overlay + ROI analysis
  let ocvScore = 0, edgeScore = 0;
  let stableCounter = 0;              // frames consecutivos con match alto
  const stableNeeded = 10;            // ~10 frames
  let autoCooldown = false;

  function openCvDetectCardInROI(imgData, gw, gh){
    const cv = window.cv; if(!cv || !cv.Mat) return null;
    try{
      const src = cv.matFromImageData(imgData);
      const gray=new cv.Mat(), blur=new cv.Mat(), edges=new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
      // thresholds segun media
      let sum=0; const d=blur.data; for(let i=0;i<d.length;i++) sum+=d[i];
      const mean=sum/d.length; const lo=Math.max(0,0.66*mean), hi=Math.min(255,1.33*mean);
      cv.Canny(blur, edges, lo, hi);
      const contours=new cv.MatVector(), hier=new cv.Mat();
      cv.findContours(edges, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let best=0;
      for(let i=0;i<contours.size();i++){
        const cnt=contours.get(i); const area=cv.contourArea(cnt);
        if(area < (gw*gh)*0.06){ cnt.delete(); continue; }
        const peri=cv.arcLength(cnt,true); const ap=new cv.Mat();
        cv.approxPolyDP(cnt, ap, 0.02*peri, true);
        if(ap.rows===4){
          const rect=cv.minAreaRect(cnt);
          const W=rect.size.width, H=rect.size.height;
          const long=Math.max(W,H), short=Math.min(W,H);
          const ar=long/short, ideal=CR80_W/CR80_H;
          const aScore = Math.max(0, 1 - Math.min(Math.abs(ar-ideal)/0.35,1));
          const cScore = Math.max(0, Math.min(1,(area/(gw*gh))*2.0));
          best = Math.max(best, aScore*0.7 + cScore*0.3);
        }
        ap.delete(); cnt.delete();
      }
      gray.delete(); blur.delete(); edges.delete(); contours.delete(); hier.delete(); src.delete();
      return best;
    }catch(e){ return null; }
  }

  function startOverlayLoop(){
    const ctx = overlay.getContext('2d', {willReadFrequently:true});
    const fctx = frameCv.getContext('2d', {willReadFrequently:true});

    const loop = () => {
      if(!video.videoWidth){ raf=requestAnimationFrame(loop); return; }
      overlay.width = video.clientWidth;  // tama√±o CSS del box
      overlay.height= video.clientHeight;

      // ROI guia en coords del video real
      const gw = parseInt(slider.value,10);
      const gh = Math.round(gw / (CR80_W/CR80_H));
      guideWEl.textContent = gw; guideHEl.textContent = gh;

      // Dibujo m√°scara gris y recorto ROI transparente:
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,overlay.width,overlay.height);

      const gx = Math.round((overlay.width - gw)/2);
      const gy = Math.round((overlay.height - gh)/2);
      ctx.clearRect(gx,gy,gw,gh);

      // Marco de ROI
      const strokeCol = '#a78bfa';
      ctx.strokeStyle = strokeCol; ctx.lineWidth = 4; ctx.strokeRect(gx,gy,gw,gh);

      // --- an√°lisis de p√≠xeles en ROI (del frame NO espejado) ---
      // Dibujar el frame real en canvas oculto con tama√±o videoWidth/Height
      frameCv.width = video.videoWidth; frameCv.height = video.videoHeight;
      fctx.drawImage(video, 0, 0, frameCv.width, frameCv.height);

      // Convertir coords overlay -> coords reales manteniendo proporci√≥n de dibujado en <video>
      // Porque <video> puede letterboxear; calculemos offsets:
      const scale = Math.min(
        video.clientWidth / video.videoWidth,
        video.clientHeight / video.videoHeight
      );
      const realW = video.videoWidth * scale;
      const realH = video.videoHeight * scale;
      const offsetX = (video.clientWidth - realW)/2;
      const offsetY = (video.clientHeight - realH)/2;

      // ROI en coords reales del frame
      const rx = Math.max(0, Math.round((gx - offsetX)/scale));
      const ry = Math.max(0, Math.round((gy - offsetY)/scale));
      const rw = Math.max(1, Math.round(gw/scale));
      const rh = Math.max(1, Math.round(gh/scale));

      let imgData=null;
      try{ imgData = fctx.getImageData(rx, ry, rw, rh); }catch(e){ imgData = null; }

      // 1) Edge score en per√≠metro
      edgeScore = 0;
      if(imgData){
        const data = imgData.data;
        const thick=3; let edge=0, total=0;
        const isEdge=(r,g,b)=>{ const lum=0.299*r+0.587*g+0.114*b; return (lum<80 || lum>200); };
        for(let y=0;y<rh;y++){
          for(let x=0;x<rw;x++){
            const bt=(y<thick)||(y>=rh-thick)||(x<thick)||(x>=rw-thick);
            if(!bt) continue;
            const i=(y*rw+x)*4; if(isEdge(data[i],data[i+1],data[i+2])) edge++; total++;
          }
        }
        edgeScore = total? edge/total : 0;
      }

      // 2) OpenCV score (cada 3 frames)
      if(loop._f===undefined) loop._f=0;
      if(imgData && (loop._f%3===0)){
        const s = openCvDetectCardInROI(imgData, rw, rh);
        if(s!=null) ocvScore = s; // 0..1
      }
      loop._f++;

      const combined = Math.max(edgeScore, ocvScore||0);
      matchPct.textContent = Math.round(edgeScore*100)+'%';
      ocvPct.textContent   = Math.round((ocvScore||0)*100)+'%';

      // Verde si listo
      ctx.strokeStyle = combined>=0.7 ? '#22c55e' : '#a78bfa';
      ctx.lineWidth=4; ctx.strokeRect(gx,gy,gw,gh);
      ctx.fillStyle='#fff';
      ctx.font='bold 14px system-ui,-apple-system';
      ctx.fillText(`Gu√≠a CR80 ‚Äî Match ${Math.round(combined*100)}%`, gx+10, Math.max(18, gy-8));

      // AUTOCAPTURE estable
      if(useGuide.checked && autoCap.checked){
        if(combined>=0.7){ stableCounter++; } else { stableCounter=0; }
        if(stableCounter>=stableNeeded && !autoCooldown){
          autoCooldown = true;
          capture(); // dispara
          setTimeout(()=>{ autoCooldown=false; }, 2500);
          stableCounter = 0;
        }
      } else {
        stableCounter=0;
      }

      raf = requestAnimationFrame(loop);
    };
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(loop);
  }

  // Captura de foto (no espejada)
  function capture(){
    if(!video.videoWidth){ alert('La c√°mara a√∫n no est√° lista.'); return; }
    const c=document.createElement('canvas');
    c.width = video.videoWidth; c.height = video.videoHeight;
    const x=c.getContext('2d'); x.drawImage(video,0,0,c.width,c.height);
    const url=c.toDataURL('image/jpeg',0.92);

    imgEl.src = url;
    imgCard.style.display = '';
    resCard.style.display = 'none';
    procStep.textContent = 'Imagen capturada';
    window.scrollTo({top: imgCard.offsetTop-12, behavior:'smooth'});
  }

  // Procesado (IPD)
  function process(){
    const src = imgEl.src;
    if(!src){ return; }
    (async () => {
      procStep.textContent = 'Detectando‚Ä¶';
      const m = await loadImage(src);

      // Escala: siempre desde la gu√≠a (ancho en px del rect√°ngulo mostrado)
      let pxPerMm = parseInt(slider.value,10) / CR80_W;
      pxmm.textContent = pxPerMm.toFixed(3);
      scaleFrom.textContent = 'De gu√≠a CR80 en overlay';

      // Landmarks (MediaPipe si est√°, si no estimaci√≥n)
      const LM = await getLandmarks(m);

      // IPD
      const dx=LM.r.x-LM.l.x, dy=LM.r.y-LM.l.y;
      const ipd = Math.round((Math.hypot(dx,dy)/pxPerMm)*10)/10;

      // Anotar
      const anC = document.createElement('canvas');
      anC.width = m.width; anC.height = m.height;
      const a = anC.getContext('2d'); a.drawImage(m,0,0);
      a.fillStyle='#f00';
      a.beginPath(); a.arc(LM.l.x,LM.l.y,10,0,Math.PI*2); a.fill();
      a.beginPath(); a.arc(LM.r.x,LM.r.y,10,0,Math.PI*2); a.fill();
      a.strokeStyle='#f00'; a.lineWidth=3;
      a.beginPath(); a.moveTo(LM.l.x,LM.l.y); a.lineTo(LM.r.x,LM.r.y); a.stroke();
      a.font='bold 24px system-ui,-apple-system'; a.fillStyle='#fff'; a.strokeStyle='#000'; a.lineWidth=5;
      const mx=(LM.l.x+LM.r.x)/2, my=(LM.l.y+LM.r.y)/2-20;
      a.strokeText(`IPD: ${ipd} mm`, mx-70, my); a.fillText(`IPD: ${ipd} mm`, mx-70, my);

      const url = anC.toDataURL('image/png');
      annotImg.src = url; annotDl.href = url; annotDl.download = `annotated-${Date.now()}.png`;

      ipdVal.textContent = ipd+' mm';
      methodBadge.textContent = LM.method;
      resCard.style.display = '';
      procStep.textContent = 'Hecho';
      window.scrollTo({top: resCard.offsetTop-12, behavior:'smooth'});
    })();
  }

  function loadImage(url){
    return new Promise((res,rej)=>{ const im=new Image(); im.src=url; im.onload=()=>res(im); im.onerror=rej; });
  }

  function getLandmarks(img){
    return new Promise((resolve)=>{
      if(faceMesh){
        const c=document.createElement('canvas'); c.width=img.width; c.height=img.height;
        c.getContext('2d').drawImage(img,0,0);
        faceMesh.onResults(r=>{
          if(r.multiFaceLandmarks && r.multiFaceLandmarks[0]){
            const L=r.multiFaceLandmarks[0];
            const iris=(arr)=>({x:arr.reduce((s,l)=>s+l.x*img.width,0)/arr.length, y:arr.reduce((s,l)=>s+l.y*img.height,0)/arr.length});
            resolve({ l: iris(L.slice(473,477)), r: iris(L.slice(468,472)), method:'MediaPipe' });
          }else{
            const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
            resolve({ l:{x:cx-d/2,y:cy}, r:{x:cx+d/2,y:cy}, method:'Estimaci√≥n' });
          }
        });
        faceMesh.send({image:c});
      }else{
        const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
        resolve({ l:{x:cx-d/2,y:cy}, r:{x:cx+d/2,y:cy}, method:'Estimaci√≥n' });
      }
    });
  }

  // Events
  btnCam.addEventListener('click', startCamera);
  btnStop.addEventListener('click', stopCamera);
  btnCapture.addEventListener('click', capture);
  btnProcess.addEventListener('click', process);
  fileInput.addEventListener('change', (e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    const rd=new FileReader();
    rd.onload=ev=>{ imgEl.src=ev.target.result; imgCard.style.display=''; resCard.style.display='none'; procStep.textContent='Imagen cargada'; };
    rd.readAsDataURL(f);
  });
  slider.addEventListener('input', ()=>{
    const gw=parseInt(slider.value,10); guideWEl.textContent=gw; guideHEl.textContent=Math.round(gw/CR80_AR);
  });

})();
</script>
</body>
</html>