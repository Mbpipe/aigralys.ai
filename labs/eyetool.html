<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Medidor √ìptico Facial ‚Äî Gu√≠a CR80 + OpenCV/MediaPipe</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 UMD + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- MediaPipe FaceMesh (cargado on-demand desde el propio app) -->

  <!-- OpenCV.js (opcional; si no carga, seguimos con fallback) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    html,body{background:#eef2ff}
    video.cam {
      width: 100%;
      height: auto;
      max-height: 62vh;           /* asegura visibilidad en iOS */
      background: #000;
      border-radius: 0.75rem;
      object-fit: cover;
      transform: scaleX(-1);      /* espejo para c√°mara frontal */
    }
    canvas.overlay {
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:none;
    }
    .tag {font-variant-numeric: tabular-nums;}
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {useState,useRef,useEffect,useMemo} = React;

/* ---------- Iconos simples (sin dependencias) --------- */
const I = ({children}) => <span className="inline-block w-5 text-lg">{children}</span>;

/* ---------- Constantes ---------- */
const CR80_W = 85.60, CR80_H = 53.98, CR80_AR = CR80_W/CR80_H;

/* ---------- Utilidades ---------- */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

/* ---------- App ---------- */
function App(){
  const [faceMeshReady,setFaceMeshReady] = useState(false);
  const [loadingModels,setLoadingModels] = useState(true);

  const [image,setImage] = useState(null);
  const [error,setError] = useState('');
  const [processing,setProcessing] = useState(false);
  const [processingStep,setProcessingStep] = useState('');
  const [annotated,setAnnotated] = useState(null);
  const [results,setResults] = useState(null);

  const videoRef = useRef(null);
  const streamRef = useRef(null);
  const canvasRef = useRef(null);

  /* ---- Gu√≠a CR80 ---- */
  const [useGuide,setUseGuide] = useState(false);
  const [guideLocked,setGuideLocked] = useState(false);
  const [guidePx,setGuidePx] = useState(260);         // ancho en px del rect√°ngulo gu√≠a
  const [guideMatch,setGuideMatch] = useState(0);     // 0..1
  const [cameraActive,setCameraActive] = useState(false);

  const pxPerMmFromGuide = useMemo(()=> guideLocked ? (guidePx/CR80_W) : null, [guideLocked,guidePx]);

  /* ---- Cargar MediaPipe si est√° disponible ---- */
  useEffect(()=>{
    const init = ()=>{
      try{
        const fm = new window.FaceMesh({
          locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
        });
        fm.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
        window.__faceMesh = fm;
        setFaceMeshReady(true);
      }catch(e){
        console.log('MediaPipe init error', e);
        setFaceMeshReady(false);
      }finally{ setLoadingModels(false); }
    };

    if (typeof window.FaceMesh === 'undefined'){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
      s.async = true;
      s.onload = ()=>{
        const s2 = document.createElement('script');
        s2.src='https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';
        s2.async = true;
        s2.onload = init;
        s2.onerror = ()=>{ setLoadingModels(false); };
        document.body.appendChild(s2);
      };
      s.onerror = ()=> setLoadingModels(false);
      document.body.appendChild(s);
    }else{ init(); }
  },[]);

  /* ---- C√°mara: iOS-safe start ---- */
  const startCamera = async ()=>{
    setError('');
    try{
      const v = videoRef.current;
      if(!v) return;

      // iOS Safari requisitos
      v.setAttribute('playsinline','');
      v.setAttribute('autoplay','');
      v.muted = true;
      v.playsInline = true;

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: {ideal:'user'}, width: {ideal:1280}, height:{ideal:720} },
        audio: false
      });
      streamRef.current = stream;
      v.srcObject = stream;

      // Mostramos UI de c√°mara de inmediato
      setCameraActive(true);

      // Intento de reproducci√≥n inmediato
      const tryPlay = async ()=>{
        try{ await v.play(); }
        catch(e){
          // Reintento breve; en iOS a veces necesita un ciclo m√°s
          setTimeout(async ()=>{
            try{ await v.play(); }catch(e2){ console.log('play() still blocked', e2); }
          }, 120);
        }
      };
      tryPlay();
    }catch(err){
      setError('No se pudo acceder a la c√°mara: ' + err.message);
      setCameraActive(false);
    }
  };

  const stopCamera = ()=>{
    try{
      const v = videoRef.current;
      if (v) { v.pause(); v.srcObject = null; }
      if (streamRef.current){
        streamRef.current.getTracks().forEach(t=>t.stop());
        streamRef.current = null;
      }
    }finally{
      setCameraActive(false);
      setUseGuide(false);
      setGuideLocked(false);
      setGuideMatch(0);
    }
  };

  /* ---- C√°lculo de "match%" de la gu√≠a en vivo ---- */
  useEffect(()=>{
    if (!cameraActive || !useGuide) return;
    let raf = 0;
    const v = videoRef.current;
    const c = canvasRef.current;
    const ctx = c.getContext('2d', { willReadFrequently:true });

    const loop = ()=>{
      if (!v.videoWidth) { raf = requestAnimationFrame(loop); return; }

      // Pintamos frame
      c.width = v.videoWidth; c.height = v.videoHeight;
      ctx.save();
      ctx.scale(-1,1); ctx.drawImage(v, -c.width, 0, c.width, c.height); // espejo
      ctx.restore();

      // ROI gu√≠a (centrada)
      const gw = guidePx, gh = Math.round(guidePx / CR80_AR);
      const gx = Math.round((c.width - gw)/2);
      const gy = Math.round((c.height - gh)/2);

      // Calcular densidad de bordes en el per√≠metro (Canny simplificado)
      const img = ctx.getImageData(gx, gy, gw, gh);
      let edgeCount = 0, samples = 0;
      // muestreamos 4 bordes con grosor 3px
      const thick = 3;
      const isEdge = (r,g,b)=>{
        // contraste local simple (no Canny puro pero suficiente para feedback en vivo)
        const lum = 0.299*r + 0.587*g + 0.114*b;
        return lum < 80 || lum > 200; // "alto contraste"
      };
      for (let y=0; y<gh; y++){
        for(let x=0; x<gw; x++){
          const onTop    = (y < thick);
          const onBottom = (y >= gh-thick);
          const onLeft   = (x < thick);
          const onRight  = (x >= gw-thick);
          if (onTop||onBottom||onLeft||onRight){
            const idx = (y*gw + x)*4;
            if (isEdge(img.data[idx], img.data[idx+1], img.data[idx+2])) edgeCount++;
            samples++;
          }
        }
      }
      const match = samples ? edgeCount/samples : 0;
      setGuideMatch(match);

      // Dibujo de overlay (rect√°ngulo grisado + etiqueta)
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.clearRect(gx,gy,gw,gh);
      ctx.strokeStyle = match>=0.7 ? '#22c55e' : '#a78bfa';
      ctx.lineWidth = 4; ctx.strokeRect(gx,gy,gw,gh);
      ctx.font = 'bold 16px system-ui, -apple-system, Segoe UI';
      ctx.fillStyle = '#ffffff';
      const pct = Math.round(match*100);
      ctx.fillText(`Gu√≠a CR80 ‚Ä¢ Match ${pct}%`, gx+12, gy-10 < 20 ? gy+24 : gy-10);

      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    return ()=> cancelAnimationFrame(raf);
  },[cameraActive,useGuide,guidePx]);

  /* ---- Capturar foto (usa gu√≠a si est√° bloqueada) ---- */
  const capturePhoto = ()=>{
    const v = videoRef.current;
    if (!v || !v.videoWidth){ setError('La c√°mara a√∫n no est√° lista.'); return; }

    const tmp = document.createElement('canvas');
    tmp.width = v.videoWidth; tmp.height = v.videoHeight;
    const tctx = tmp.getContext('2d');
    // espejo -> deshacer para que la imagen final quede normal
    tctx.drawImage(v, 0, 0, tmp.width, tmp.height);

    const dataUrl = tmp.toDataURL('image/jpeg', 0.92);
    setImage(dataUrl);
    setAnnotated(null);
    setResults(null);
    setError('');

    // dejamos la c√°mara encendida para repetir capturas si quiere
  };

  /* ---- Subir imagen ---- */
  const onUpload = e=>{
    const f = e.target.files?.[0]; if (!f) return;
    const rd = new FileReader();
    rd.onload = ev => { setImage(ev.target.result); setAnnotated(null); setResults(null); setError(''); };
    rd.readAsDataURL(f);
  };

  /* ------ Procesar (muy abreviado; aqu√≠ mantengo tu l√≥gica base y la escala por gu√≠a) ----- */
  const process = async ()=>{
    if (!image){ setError('No hay imagen para procesar.'); return; }
    setProcessing(true); setProcessingStep('Preparando‚Ä¶'); setError('');
    try{
      const img = await new Promise((res,rej)=>{
        const im = new Image(); im.src = image;
        im.onload=()=>res(im); im.onerror=rej;
      });

      const can = document.createElement('canvas');
      can.width = img.width; can.height = img.height;
      const ctx = can.getContext('2d'); ctx.drawImage(img,0,0);

      // 1) escala
      let pxPerMm = null;
      if (pxPerMmFromGuide){                       // ESCALA CON GU√çA
        pxPerMm = pxPerMmFromGuide;
      }else{
        // Fallback: estimaci√≥n muy conservadora (en tu proyecto original aqu√≠ entra OpenCV/detecci√≥n)
        const approxWidthPx = Math.min(img.width,img.height) * 0.22;
        pxPerMm = approxWidthPx / CR80_W;
      }

      // 2) landmarks (muy b√°sico; si est√° MediaPipe, √∫salo)
      const getLandmarks = ()=>{
        return new Promise((resolve)=>{
          if (window.__faceMesh){
            const c2 = document.createElement('canvas');
            c2.width = img.width; c2.height = img.height;
            const x2 = c2.getContext('2d'); x2.drawImage(img,0,0);
            window.__faceMesh.onResults((r)=>{
              if (r.multiFaceLandmarks && r.multiFaceLandmarks[0]){
                const L = r.multiFaceLandmarks[0];
                const iris = (a,b)=>({
                  x: a.reduce((s,l)=>s+l.x*img.width,0)/a.length,
                  y: a.reduce((s,l)=>s+l.y*img.height,0)/a.length
                });
                const rp = iris(L.slice(468,472));
                const lp = iris(L.slice(473,477));
                resolve({rightPupil:rp,leftPupil:lp, method:'MediaPipe', confidence:0.95});
              }else{
                const cx = img.width/2, cy = img.height*0.45, d = img.width*0.15;
                resolve({
                  rightPupil:{x:cx+d/2,y:cy}, leftPupil:{x:cx-d/2,y:cy},
                  method:'Estimaci√≥n', confidence:0.65
                });
              }
            });
            window.__faceMesh.send({image:c2});
          }else{
            const cx = img.width/2, cy = img.height*0.45, d = img.width*0.15;
            resolve({
              rightPupil:{x:cx+d/2,y:cy}, leftPupil:{x:cx-d/2,y:cy},
              method:'Estimaci√≥n', confidence:0.65
            });
          }
        });
      };

      setProcessingStep('Detectando pupilas‚Ä¶');
      const lm = await getLandmarks();

      // 3) IPD
      const dx = lm.rightPupil.x - lm.leftPupil.x, dy = lm.rightPupil.y - lm.leftPupil.y;
      const ipd_mm = Math.round((Math.hypot(dx,dy)/pxPerMm)*10)/10;

      // 4) imagen anotada
      const out = document.createElement('canvas'); out.width = img.width; out.height = img.height;
      const a = out.getContext('2d'); a.drawImage(img,0,0);
      a.fillStyle='#f00';
      a.beginPath(); a.arc(lm.leftPupil.x, lm.leftPupil.y, 10, 0, Math.PI*2); a.fill();
      a.beginPath(); a.arc(lm.rightPupil.x, lm.rightPupil.y, 10, 0, Math.PI*2); a.fill();
      a.strokeStyle='#f00'; a.lineWidth=3; a.beginPath();
      a.moveTo(lm.leftPupil.x,lm.leftPupil.y); a.lineTo(lm.rightPupil.x,lm.rightPupil.y); a.stroke();
      a.font='bold 20px system-ui, -apple-system'; a.fillStyle='#fff'; a.strokeStyle='#000'; a.lineWidth=4;
      const mx=(lm.leftPupil.x+lm.rightPupil.x)/2, my=(lm.leftPupil.y+lm.rightPupil.y)/2 - 20;
      a.strokeText(`IPD: ${ipd_mm} mm`, mx-60,my); a.fillText(`IPD: ${ipd_mm} mm`, mx-60,my);
      const annotatedUrl = out.toDataURL('image/png');

      setResults({
        detectionMethod: lm.method,
        calibration: { px_per_mm: pxPerMm, from_guide: !!pxPerMmFromGuide },
        measurements: { DI_mm: ipd_mm }
      });
      setAnnotated(annotatedUrl);
      setProcessingStep('¬°Listo!');
    }catch(e){
      console.error(e);
      setError('No se pudo procesar la imagen: ' + (e.message||e));
    }finally{
      setTimeout(()=>{ setProcessing(false); setProcessingStep(''); }, 400);
    }
  };

  /* ---- UI ---- */
  return (
    <div className="min-h-screen p-4">
      <div className="max-w-3xl mx-auto space-y-4">
        {/* Header */}
        <div className="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-500">
          <div className="flex items-center justify-between gap-3">
            <div>
              <h1 className="text-3xl font-bold">Medidor √ìptico Facial</h1>
              <p className="text-slate-600">Gu√≠a CR80 + Detecci√≥n (OpenCV/MediaPipe)</p>
            </div>
            <div className={`px-3 py-1 rounded-lg text-sm ${faceMeshReady?'bg-emerald-50 text-emerald-700':'bg-indigo-50 text-indigo-700'}`}>
              <span className="mr-1">{faceMeshReady?'‚úÖ':'‚¨áÔ∏è'}</span>{faceMeshReady?'MediaPipe':'Cargando‚Ä¶'}
            </div>
          </div>
        </div>

        {/* Controles */}
        <div className="bg-white rounded-2xl shadow p-5">
          <h2 className="text-xl font-semibold mb-3">Captura de Imagen</h2>
          <div className="grid grid-cols-2 gap-3">
            <label className="inline-flex items-center justify-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 rounded-xl cursor-pointer">
              <I>üñºÔ∏è</I> <span>Subir Foto</span>
              <input type="file" className="hidden" accept="image/*" onChange={onUpload}/>
            </label>
            {!cameraActive ? (
              <button onClick={startCamera} className="inline-flex items-center justify-center gap-2 bg-violet-600 hover:bg-violet-700 text-white font-semibold py-3 rounded-xl">
                <I>üì∑</I> C√°mara
              </button>
            ) : (
              <button onClick={stopCamera} className="inline-flex items-center justify-center gap-2 bg-rose-600 hover:bg-rose-700 text-white font-semibold py-3 rounded-xl">
                <I>üõë</I> Cerrar C√°mara
              </button>
            )}
          </div>

          {/* C√°mara + Gu√≠a */}
          {cameraActive && (
            <div className="mt-4 relative">
              <video ref={videoRef} className="cam" autoPlay playsInline muted></video>
              {/* overlay canvas */}
              {useGuide && <canvas ref={canvasRef} className="overlay"></canvas>}

              <div className="mt-3 flex flex-wrap items-center gap-3">
                <label className="inline-flex items-center gap-2">
                  <input type="checkbox" className="scale-110" checked={useGuide} onChange={e=>{
                    setUseGuide(e.target.checked);
                    setGuideLocked(false);
                  }}/>
                  <span>Usar Gu√≠a CR80</span>
                </label>

                {useGuide && (
                  <>
                    <div className="flex-1 min-w-[220px]">
                      <input type="range" min="140" max="420" value={guidePx}
                             onChange={e=> setGuidePx(parseInt(e.target.value))}
                             className="w-full"/>
                      <div className="text-xs text-slate-600">Ancho gu√≠a: <span className="tag">{guidePx}px</span> (alto {Math.round(guidePx/CR80_AR)}px)</div>
                    </div>
                    <div className={`px-2 py-1 rounded-md text-sm ${guideMatch>=0.7?'bg-emerald-100 text-emerald-700':'bg-slate-100 text-slate-700'}`}>
                      Match: <span className="font-semibold tag">{Math.round(guideMatch*100)}%</span>
                    </div>
                    {!guideLocked ? (
                      <button disabled={guideMatch<0.7}
                              onClick={()=> setGuideLocked(true)}
                              className={`px-3 py-2 rounded-lg text-white ${guideMatch<0.7?'bg-slate-400 cursor-not-allowed':'bg-emerald-600 hover:bg-emerald-700'}`}>
                        Bloquear gu√≠a
                      </button>
                    ) : (
                      <div className="text-emerald-700 text-sm">Gu√≠a bloqueada ‚úì (escala fija)</div>
                    )}
                  </>
                )}

                <button onClick={capturePhoto} className="ml-auto inline-flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-xl">
                  <I>üì∏</I> Capturar
                </button>
              </div>
            </div>
          )}
        </div>

        {/* Imagen cargada */}
        {image && (
          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Imagen Actual</h3>
            <img src={image} alt="captura" className="w-full rounded-lg shadow"/>
            <button onClick={process} disabled={processing}
                    className="mt-4 inline-flex items-center justify-center gap-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-slate-400 text-white font-semibold px-4 py-2 rounded-xl">
              <I>üßÆ</I> {processing?'Procesando‚Ä¶':'Procesar'}
            </button>
            {processing && <div className="text-sm text-slate-600 mt-2">{processingStep}</div>}
          </div>
        )}

        {/* Resultados */}
        {results && (
          <div className="bg-white rounded-2xl shadow p-5 space-y-3">
            <div className="flex items-center justify-between">
              <h3 className="font-semibold">Resultado</h3>
              <span className="text-xs px-2 py-1 rounded bg-slate-100">{results.detectionMethod || results.detectionMethod}</span>
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div className="p-3 rounded bg-indigo-50">
                <div className="text-xs text-slate-600">IPD</div>
                <div className="text-2xl font-bold">{results.measurements.DI_mm} mm</div>
              </div>
              <div className="p-3 rounded bg-violet-50">
                <div className="text-xs text-slate-600">Escala (px/mm)</div>
                <div className="text-xl font-semibold tag">{results.calibration.px_per_mm.toFixed(3)}</div>
                <div className="text-xs text-slate-500">{results.calibration.from_guide?'De gu√≠a CR80':'Estimaci√≥n'}</div>
              </div>
            </div>
            {annotated && (
              <div className="mt-2">
                <h4 className="font-semibold mb-2">Imagen Anotada</h4>
                <img src={annotated} className="w-full rounded-lg shadow" alt="anotada"/>
                <a download={`annotated-${Date.now()}.png`} href={annotated}
                   className="inline-block mt-3 px-3 py-2 rounded bg-blue-600 text-white">Descargar PNG</a>
              </div>
            )}
          </div>
        )}

        {error && (
          <div className="bg-red-50 text-red-800 border border-red-200 rounded-xl p-4">
            <div className="font-semibold mb-1">Error</div>
            <div className="text-sm">{error}</div>
          </div>
        )}

        {/* Ayuda de la gu√≠a */}
        <div className="bg-white rounded-2xl shadow p-5">
          <h3 className="font-semibold mb-2">C√≥mo usar la Gu√≠a CR80</h3>
          <ol className="list-decimal ml-5 space-y-1 text-sm text-slate-700">
            <li>Enciende la c√°mara y activa ‚ÄúUsar Gu√≠a CR80‚Äù.</li>
            <li>Ajusta el tama√±o de la gu√≠a y coloca una tarjeta de cr√©dito real dentro del rect√°ngulo.</li>
            <li>Cuando ‚ÄúMatch‚Äù ‚â• 70%, pulsa <b>Bloquear gu√≠a</b> y luego <b>Capturar</b>.</li>
            <li>Procesa la imagen. Si no bloqueas, se intentar√° estimar la tarjeta autom√°ticamente.</li>
          </ol>
          <p className="text-xs text-slate-500 mt-2">La gu√≠a fija la escala: px/mm = ancho_gu√≠a_px / 85.60 mm.</p>
        </div>

        <div className="text-center text-xs text-slate-500 py-4">¬© 2025 ‚Äî CR80 Guide + OpenCV + MediaPipe</div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>