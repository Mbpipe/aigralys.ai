<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Medidor √ìptico Facial ‚Äî C√°mara + Gu√≠a CR80</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 UMD + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- OpenCV opcional para ROI -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    html,body{background:#eef2ff}
    video.cam{
      width:100%;
      height:auto;
      max-height:62vh;
      background:#000;
      border-radius:.75rem;
      object-fit:cover;
      transform:scaleX(-1);
    }
    canvas.overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;}
    .tag{font-variant-numeric:tabular-nums}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {useState,useEffect,useRef,useMemo} = React;
const CR80_W=85.60, CR80_AR=85.60/53.98;

function App(){
  const [dbg,setDbg]=useState({secure:window.isSecureContext, hasMedia:!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia), state:'idle', msg:''});
  const [image,setImage]=useState(null);
  const [error,setError]=useState('');
  const [cameraActive,setCameraActive]=useState(false);

  const videoRef=useRef(null);
  const streamRef=useRef(null);
  const overlayRef=useRef(null);

  const [useGuide,setUseGuide]=useState(false);
  const [guidePx,setGuidePx]=useState(260);
  const [edgeMatch,setEdgeMatch]=useState(0);
  const [ocvMatch,setOcvMatch]=useState(0);

  // Enumerar dispositivos al montar (ayuda a diagnosticar permisos/visibilidad)
  useEffect(()=>{
    if(!navigator.mediaDevices?.enumerateDevices) return;
    navigator.mediaDevices.enumerateDevices().then(list=>{
      const cams=list.filter(d=>d.kind==='videoinput');
      setDbg(d=>({...d,cams:cams.map(c=>({id:c.deviceId||'(sin id)',label:c.label||'(sin label)'}))}));
    }).catch(e=>{
      setDbg(d=>({...d,msg:'enumerateDevices error: '+e.name}));
    });
  },[]);

  // Iniciar c√°mara con robustez iOS
  const startCamera = async () => {
    setError('');
    setDbg(d=>({...d,state:'requesting',msg:''}));

    if (!window.isSecureContext){
      setError('La c√°mara requiere HTTPS / contexto seguro.');
      setDbg(d=>({...d,state:'error',msg:'No secure context'}));
      return;
    }
    if (!navigator.mediaDevices?.getUserMedia){
      setError('getUserMedia no est√° disponible en este navegador.');
      setDbg(d=>({...d,state:'error',msg:'No mediaDevices.getUserMedia'}));
      return;
    }
    const v=videoRef.current;
    if(!v){ setDbg(d=>({...d,state:'error',msg:'<video> no disponible'})); return; }

    // flags exigidos por iOS
    v.setAttribute('playsinline','true');
    v.setAttribute('autoplay','true');
    v.muted=true; v.playsInline=true;

    try{
      // solicitar c√°mara FRONTAL
      const stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{facingMode:{ideal:'user'},width:{ideal:1280},height:{ideal:720}}
      });
      streamRef.current=stream;
      v.srcObject=stream;

      // esperar metadata (dimensiones listas)
      await new Promise(res=>{
        if (v.readyState>=1 && v.videoWidth) res();
        else v.addEventListener('loadedmetadata', res, {once:true});
      });

      // play (si se rechaza, mostramos motivo)
      const p=v.play();
      if (p && p.catch) {
        await p.catch(err=>{
          setDbg(d=>({...d,msg:'video.play() rechazado: '+err.name}));
        });
      }

      setCameraActive(true);
      setDbg(d=>({...d,state:'ready',msg:d.msg||'ok'}));
    }catch(err){
      setError('No se pudo acceder a la c√°mara: '+err.name+(err.message?(' ‚Äî '+err.message):''));
      setDbg(d=>({...d,state:'error',msg:err.name}));
      // Si estaba denegado permanentemente, ofrece fallback
    }
  };

  // iOS: a veces onClick no cuenta como gesto; usamos pointerdown
  const onCameraButtonPointerDown = () => { startCamera(); };

  const stopCamera = () => {
    const v=videoRef.current;
    try{ v?.pause(); }catch{}
    if (v) v.srcObject=null;
    if (streamRef.current){ streamRef.current.getTracks().forEach(t=>t.stop()); streamRef.current=null; }
    setCameraActive(false);
    setDbg(d=>({...d,state:'idle'}));
  };

  // Capturar frame actual
  const capturePhoto=()=>{
    const v=videoRef.current;
    if(!v || !v.videoWidth){ setError('La c√°mara a√∫n no est√° lista.'); return; }
    const c=document.createElement('canvas'); c.width=v.videoWidth; c.height=v.videoHeight;
    const x=c.getContext('2d'); x.drawImage(v,0,0,c.width,c.height);
    setImage(c.toDataURL('image/jpeg',0.92));
  };

  // Subir desde galer√≠a
  const onUpload=e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const rd=new FileReader();
    rd.onload=ev=>{ setImage(ev.target.result); setError(''); };
    rd.readAsDataURL(f);
  };

  /* Overlay simple de gu√≠a (con ‚Äúmatch‚Äù de bordes) */
  useEffect(()=>{
    if(!cameraActive || !useGuide) return;
    let raf=0;
    const v=videoRef.current, c=overlayRef.current;
    const ctx=c.getContext('2d',{willReadFrequently:true});

    const loop=()=>{
      if(!v.videoWidth){ raf=requestAnimationFrame(loop); return; }
      c.width=v.videoWidth; c.height=v.videoHeight;

      // Fondo gris + ventana
      const gw=guidePx, gh=Math.round(guidePx/CR80_AR);
      const gx=Math.round((c.width-gw)/2), gy=Math.round((c.height-gh)/2);
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,c.width,c.height);
      ctx.clearRect(gx,gy,gw,gh);
      ctx.strokeStyle='#a78bfa'; ctx.lineWidth=4; ctx.strokeRect(gx,gy,gw,gh);

      // Match r√°pido por bordes del rect
      const img=ctx.getImageData(gx,gy,gw,gh);
      const t=3; let edge=0, total=0;
      const isEdge=(r,g,b)=>{ const lum=0.299*r+0.587*g+0.114*b; return (lum<80 || lum>200); };
      for(let y=0;y<gh;y++){
        for(let x=0;x<gw;x++){
          const per=(y<t)||(y>=gh-t)||(x<t)||(x>=gw-t);
          if(!per) continue;
          const i=(y*gw+x)*4; if(isEdge(img.data[i],img.data[i+1],img.data[i+2])) edge++; total++;
        }}
      const edgeScore = total? edge/total : 0;
      setEdgeMatch(edgeScore);

      raf=requestAnimationFrame(loop);
    };
    raf=requestAnimationFrame(loop);
    return()=> cancelAnimationFrame(raf);
  },[cameraActive,useGuide,guidePx]);

  const openSystemCameraFallback = () => {
    document.getElementById('sysCamInput')?.click();
  };

  return (
    <div className="min-h-screen p-4">
      <div className="max-w-3xl mx-auto space-y-4">
        <div className="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-500">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl font-bold">Medidor √ìptico Facial</h1>
              <p className="text-slate-600">C√°mara embebida + Gu√≠a CR80</p>
            </div>
            <div className="text-xs bg-slate-100 px-2 py-1 rounded mono">
              secure:{String(dbg.secure)} media:{String(dbg.hasMedia)}
            </div>
          </div>
          <div className="mt-2 text-xs mono text-slate-600">
            estado: <b>{dbg.state}</b> {dbg.msg ? `‚Äî ${dbg.msg}` : ''}
            {Array.isArray(dbg.cams)&&dbg.cams.length>0 && (
              <span> ‚Ä¢ cams: {dbg.cams.map(c=>c.label||'cam').join(', ')}</span>
            )}
          </div>
        </div>

        <div className="bg-white rounded-2xl shadow p-5">
          <h2 className="text-xl font-semibold mb-3">Captura de Imagen</h2>

          <div className="grid grid-cols-2 gap-3">
            <label className="inline-flex items-center justify-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 rounded-xl cursor-pointer">
              üñºÔ∏è <span>Subir Foto</span>
              <input type="file" className="hidden" accept="image/*" onChange={onUpload}/>
            </label>

            {!cameraActive ? (
              <button
                type="button"
                onPointerDown={onCameraButtonPointerDown}
                className="inline-flex items-center justify-center gap-2 bg-violet-600 hover:bg-violet-700 text-white font-semibold py-3 rounded-xl">
                üì∑ C√°mara
              </button>
            ) : (
              <button type="button" onClick={stopCamera}
                className="inline-flex items-center justify-center gap-2 bg-rose-600 hover:bg-rose-700 text-white font-semibold py-3 rounded-xl">
                üõë Cerrar C√°mara
              </button>
            )}
          </div>

          {/* Fallback: c√°mara del sistema (abre la app de c√°mara/galer√≠a) */}
          {!cameraActive && (
            <div className="mt-3 flex items-center gap-2">
              <button type="button" onClick={openSystemCameraFallback}
                className="text-sm underline text-slate-600">Usar c√°mara del sistema (fallback)</button>
              <input id="sysCamInput" type="file" accept="image/*" capture="user" className="hidden"
                     onChange={onUpload}/>
            </div>
          )}

          {cameraActive && (
            <div className="mt-4 relative">
              {/* IMPORTANT: camelCase en JSX */}
              <video ref={videoRef} className="cam" autoPlay playsInline muted></video>
              {useGuide && <canvas ref={overlayRef} className="overlay"></canvas>}

              <div className="mt-3 flex flex-wrap items-center gap-3">
                <label className="inline-flex items-center gap-2">
                  <input type="checkbox" className="scale-110" checked={useGuide}
                         onChange={e=> setUseGuide(e.target.checked)}/>
                  <span>Usar Gu√≠a CR80</span>
                </label>

                {useGuide && (
                  <>
                    <div className="flex-1 min-w-[220px]">
                      <input type="range" min="140" max="420" value={guidePx}
                             onChange={e=> setGuidePx(parseInt(e.target.value))} className="w-full"/>
                      <div className="text-xs text-slate-600">
                        Ancho gu√≠a: <span className="tag">{guidePx}px</span> (alto {Math.round(guidePx/CR80_AR)}px) ‚Äî
                        Match bordes: <b className="tag">{Math.round(edgeMatch*100)}%</b>
                      </div>
                    </div>
                  </>
                )}

                <button onClick={capturePhoto}
                        className="ml-auto inline-flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-xl">
                  üì∏ Capturar
                </button>
              </div>
            </div>
          )}
        </div>

        {image && (
          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Imagen Actual</h3>
            <img src={image} alt="captura" className="w-full rounded-lg shadow"/>
          </div>
        )}

        {error && (
          <div className="bg-red-50 text-red-800 border border-red-200 rounded-xl p-4">
            <div className="font-semibold mb-1">Error</div>
            <div className="text-sm">{error}</div>
          </div>
        )}

        <div className="text-center text-xs text-slate-500 py-4">¬© 2025 ‚Äî C√°mara + Gu√≠a CR80</div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>