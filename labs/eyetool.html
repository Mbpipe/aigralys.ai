<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Medidor √ìptico Facial ‚Äî CR80 + OpenCV/MediaPipe</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<link rel="preconnect" href="https://docs.opencv.org">
<style>
  :root{--bg:#eef2ff;--card:#fff;--ink:#0f172a;--muted:#64748b;--vio:#6d28d9;--ok:#16a34a;--err:#dc2626}
  *{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:760px;margin:18px auto;padding:0 12px}
  .card{background:var(--card);border-radius:16px;box-shadow:0 10px 28px rgba(2,6,23,.08);padding:14px}
  h1{margin:0 0 4px 0;font-size:28px} h2{margin:0 0 10px 0;font-size:20px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pill{background:#eef2ff;border-radius:999px;padding:6px 10px;font-size:12px}
  button{border:0;border-radius:12px;padding:12px 16px;font-weight:800;cursor:pointer;color:#fff;background:var(--vio)}
  button.red{background:var(--err)} button.gray{background:#334155}
  button:disabled{opacity:.5;cursor:not-allowed}
  .pane{position:relative;border-radius:14px;overflow:hidden;background:#000}
  video{display:block;width:100%;height:auto;max-height:60vh;object-fit:cover;transform:scaleX(-1)}
  img.shot{display:none;width:100%;height:auto}
  canvas.hud{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  .badge{position:absolute;left:14px;top:12px;color:#fff;font-weight:800;text-shadow:0 2px 6px rgba(0,0,0,.6)}
  .meter{position:absolute;left:14px;bottom:12px;background:rgba(2,6,23,.68);color:#fff;border-radius:10px;padding:6px 10px;font-size:12px}
  .small{font-size:12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .box{background:#f8fafc;border-radius:12px;padding:10px}
  #log{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;background:#0b1020;color:#c7d2fe;padding:10px;border-radius:10px;max-height:160px;overflow:auto}
</style>
<!-- OpenCV (async) -->
<script src="https://docs.opencv.org/4.x/opencv.js" async></script>
<!-- MediaPipe (async) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" async></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" async></script>
</head>
<body>
<div class="wrap">
  <div class="card" style="margin-bottom:10px">
    <div class="row" style="justify-content:space-between">
      <div>
        <h1>Medidor √ìptico Facial</h1>
        <div class="small">Gu√≠a CR80 ‚Ä¢ OpenCV/MediaPipe</div>
      </div>
      <div class="row">
        <span class="pill" id="p-sec">secure: ‚Äî</span>
        <span class="pill" id="p-ocv">opencv: loading‚Ä¶</span>
        <span class="pill" id="p-sta">estado: idle</span>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Captura de Imagen</h2>
    <div class="row" style="margin:8px 0 12px">
      <label class="row">
        <button class="gray" id="pick">üñºÔ∏è Subir Foto</button>
        <input id="file" type="file" accept="image/*" style="display:none">
      </label>
      <button id="open">üì∑ C√°mara</button>
      <button id="close" class="red">üõë Cerrar</button>
    </div>

    <div class="pane" id="pane">
      <video id="v" playsinline muted></video>
      <img id="shot" class="shot" alt="">
      <canvas id="overlay" class="hud"></canvas>
      <div class="badge" id="badge" style="display:none"></div>
      <div class="meter" id="meter" style="display:none"></div>
    </div>

    <div class="row" style="margin-top:10px">
      <label class="row"><input id="useGuide" type="checkbox" checked style="scale:1.15;margin-right:6px">Usar Gu√≠a CR80</label>
      <label class="row"><input id="autoCap" type="checkbox" checked style="scale:1.15;margin-right:6px">Auto-capturar</label>
      <button id="capture" class="gray">üì∏ Capturar</button>
      <button id="process" class="gray">üßÆ Procesar</button>
    </div>
    <div class="small" style="margin-top:6px">
      Auto-captura: OpenCV ‚â• 50% + quietud (12/15 frames). Si no hay OpenCV: Bordes ‚â• 70% + quietud.
    </div>

    <div id="log" style="margin-top:10px"></div>
  </div>

  <div class="card" id="out" style="display:none;margin-top:10px">
    <h2>Resultado</h2>
    <div class="grid" style="margin-top:6px">
      <div class="box">
        <div class="small">IPD</div>
        <div style="font-size:28px;font-weight:900" id="ipd">‚Äì</div>
      </div>
      <div class="box">
        <div class="small">Escala</div>
        <div style="font-weight:800"><span id="pxmm">‚Äì</span> px/mm</div>
        <div class="small" id="scaleSrc">‚Äì</div>
      </div>
    </div>
    <div style="position:relative;margin-top:10px">
      <img id="final" style="width:100%;border-radius:12px" alt="">
      <a id="dl" download="annotated.png" class="small" style="display:inline-block;margin-top:6px">Descargar PNG</a>
    </div>
  </div>
</div>

<script>
/* ---------- refs ---------- */
const v=$('v'), shot=$('shot'), pane=$('pane'), overlay=$('overlay'), ctx=overlay.getContext('2d',{willReadFrequently:true});
const badge=$('badge'), meter=$('meter'), out=$('out'), ipdEl=$('ipd'), pxmmEl=$('pxmm'), scaleSrcEl=$('scaleSrc'), finalImg=$('final'), dl=$('dl');
const btnOpen=$('open'), btnClose=$('close'), btnCapture=$('capture'), btnProcess=$('process'), pickBtn=$('pick'), fileIn=$('file');
const pSec=$('p-sec'), pOcv=$('p-ocv'), pSta=$('p-sta'), chkGuide=$('useGuide'), chkAuto=$('autoCap'), logEl=$('log');
const CR80_W=85.60, CR80_H=53.98, AR=CR80_W/CR80_H;
let stream=null, raf=0, frame=0, captured=null;
let ocvReady=false, ocvLast=null;
let guide={x:0,y:0,w:0,h:0, edge:0, ocv:0, pxPerMm:null};
let stillBuf=[], hitBuf=[], EDGE_STREAK=0, prevThumb=null;

function $(id){return document.getElementById(id)}
function log(s){ logEl.textContent=`[${new Date().toLocaleTimeString()}] ${s}\n`+logEl.textContent }
function setState(s){ pSta.textContent='estado: '+s }
pSec.textContent='secure: '+String(window.isSecureContext)

/* ---------- OpenCV ready ---------- */
if(window.cv && cv.getBuildInformation){ ocvReady=true; pOcv.textContent='opencv: ready' }
else{
  pOcv.textContent='opencv: loading‚Ä¶';
  window.Module={onRuntimeInitialized:()=>{ ocvReady=true; pOcv.textContent='opencv: ready'; log('OpenCV listo') }};
}

/* ---------- layout ---------- */
function sizeCanvases(){ overlay.width=pane.clientWidth; overlay.height=pane.clientHeight }
new ResizeObserver(sizeCanvases).observe(pane); sizeCanvases();

/* ---------- gu√≠a bajo la nariz ---------- */
function drawGuide(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!chkGuide.checked) return;
  ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,overlay.width,overlay.height);

  const vw=overlay.width, vh=overlay.height;
  const gw=Math.round(Math.min(vw,vh)*0.48); const gh=Math.round(gw/AR);
  const gx=Math.round((vw-gw)/2); const gy=Math.round(vh*0.58-gh/2);

  guide.x=gx; guide.y=gy; guide.w=gw; guide.h=gh;
  ctx.clearRect(gx,gy,gw,gh);
  const ok = (ocvReady && guide.ocv>=0.50 && isStill()) || (!ocvReady && guide.edge>=0.70 && isStill());
  ctx.lineWidth=4; ctx.strokeStyle= ok? '#16a34a' : '#a78bfa'; ctx.strokeRect(gx,gy,gw,gh);

  badge.style.display='block'; meter.style.display='block';
  badge.textContent=`Gu√≠a CR80 ‚Äî Match ${Math.round((ocvReady?guide.ocv:guide.edge)*100)}%`;
  meter.textContent=`Ancho: ${gw}px ‚Ä¢ Alto: ${gh}px ‚Ä¢ OpenCV: ${ocvReady?Math.round(guide.ocv*100):'n/a'}% ‚Ä¢ still:${Math.round(stillness()*100)}%`;
}

/* ---------- util: imagen reducida para stillness ---------- */
function tinyThumb(canvas,x,y,w,h){
  const t=document.createElement('canvas'); t.width=64; t.height=64;
  const g=t.getContext('2d'); g.drawImage(canvas, x,y,w,h, 0,0,64,64);
  return g.getImageData(0,0,64,64).data;
}
function diff(a,b){
  let sum=0, n=a.length;
  for(let i=0;i<n;i+=4){ sum+=Math.abs(a[i]-b[i])+Math.abs(a[i+1]-b[i+1])+Math.abs(a[i+2]-b[i+2]) }
  return sum/(n/4)/255/3; // 0..1
}
function stillness(){ // promedio √∫ltimos 15 (1 = quieto)
  if(stillBuf.length===0) return 0;
  const m = stillBuf.reduce((a,b)=>a+b,0)/stillBuf.length;
  return Math.max(0, 1 - m); // 1=quieto, 0=muy movido
}
function isStill(){ return stillness()>=0.85 } // ‚â•85% quieto

/* ---------- bordes Sobel (fallback) ---------- */
function edgeScore(img,w,h){
  const d=img.data, t=3; let hit=0, tot=0;
  const r=(yy,xx)=>{ const X=Math.max(0,Math.min(w-1,xx)), Y=Math.max(0,Math.min(h-1,yy)); return (Y*w+X)*4 }
  const lum=(i)=>0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const border=(y<t)||(y>=h-t)||(x<t)||(x>=w-t); if(!border) continue;
      const i=(y*w+x)*4;
      const gx=(lum(r(y,x+1))-lum(r(y,x-1)))/255;
      const gy=(lum(r(y+1,x))-lum(r(y-1,x)))/255;
      const g=Math.sqrt(gx*gx+gy*gy); if(g>0.20) hit++; tot++;
    }
  }
  return tot? hit/tot : 0;
}

/* ---------- OpenCV en ROI ---------- */
function ocvDetect(img,w,h){
  if(!ocvReady || !window.cv || !cv.Mat) return null;
  try{
    const src=cv.matFromImageData(img);
    const gray=new cv.Mat(), blur=new cv.Mat(), edges=new cv.Mat();
    cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
    cv.equalizeHist(gray,gray);
    cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
    let s=0; const dd=blur.data; for(let i=0;i<dd.length;i++) s+=dd[i];
    const m=s/dd.length, lo=Math.max(0,0.66*m), hi=Math.min(255,1.33*m);
    cv.Canny(blur,edges,lo,hi);
    const k=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,3)); cv.dilate(edges,edges,k);

    const cont=new cv.MatVector(), hier=new cv.Mat();
    cv.findContours(edges,cont,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
    let best=null, bestScore=0;
    for(let i=0;i<cont.size();i++){
      const c=cont.get(i); const area=cv.contourArea(c); if(area<(w*h)*0.08){ c.delete(); continue; }
      const r=cv.minAreaRect(c); const L=Math.max(r.size.width,r.size.height), S=Math.min(r.size.width,r.size.height);
      const ar=L/S, arS=Math.max(0,1-Math.min(Math.abs(ar-(CR80_W/CR80_H))/0.22,1));
      const contS=Math.max(0,Math.min(1,(area/(w*h))*2.0));
      const score=0.72*arS+0.28*contS;
      if(score>bestScore){ bestScore=score; best={found:true,longSidePx:L,score} }
      c.delete();
    }
    gray.delete(); blur.delete(); edges.delete(); cont.delete(); hier.delete(); src.delete();
    return best||{found:false,longSidePx:0,score:0};
  }catch(e){ log('ocv error: '+e); return null; }
}

/* ---------- bucle de c√°mara ---------- */
function loop(){
  if(!v.videoWidth){ raf=requestAnimationFrame(loop); return }
  drawGuide();
  const W=overlay.width,H=overlay.height;
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(v,0,0,W,H);
  const img=x.getImageData(guide.x,guide.y,guide.w,guide.h);

  // stillness (usar thumbn. 64x64 de la ROI)
  const th=tinyThumb(c,guide.x,guide.y,guide.w,guide.h);
  if(prevThumb){ stillBuf.push(diff(th,prevThumb)); if(stillBuf.length>15) stillBuf.shift(); }
  prevThumb=th;

  // scores
  guide.edge=edgeScore(img,guide.w,guide.h);
  if(ocvReady && frame%3===0){ const r=ocvDetect(img,guide.w,guide.h); if(r){ ocvLast=r; guide.ocv=r.found?r.score:0 } }

  // hit buffer (12 de 15 frames deben cumplir)
  const okThis = (ocvReady && ocvLast?.found && ocvLast.score>=0.50 && isStill())
              || (!ocvReady && guide.edge>=0.70 && isStill());
  hitBuf.push(okThis); if(hitBuf.length>15) hitBuf.shift();
  const hits = hitBuf.filter(Boolean).length;

  if(chkAuto.checked && hits>=12){
    log('Auto-captura: OK (score estable + quietud)');
    captureNow(true); processNow(); return; // se cierra c√°mara adentro de captureNow
  }

  frame++; raf=requestAnimationFrame(loop);
}

/* ---------- c√°mara ---------- */
async function openCam(){
  setState('opening'); log('Abriendo c√°mara‚Ä¶');
  shot.style.display='none'; out.style.display='none';
  try{
    v.setAttribute('playsinline',''); v.playsInline=true; v.muted=true;
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'user'},width:{ideal:1280},height:{ideal:720}},audio:false});
    v.srcObject=stream;
    try{await v.play()}catch{setTimeout(()=>v.play().catch(()=>{}),150)}
    setState('ready'); log('C√°mara abierta');
    // reset buffers
    stillBuf.length=0; hitBuf.length=0; prevThumb=null; ocvLast=null; guide.pxPerMm=null;
    raf=requestAnimationFrame(loop);
  }catch(e){ setState('error'); alert('No se pudo acceder a la c√°mara: '+e.message); log('gUM error: '+e) }
}
function closeCam(){
  cancelAnimationFrame(raf);
  try{v.pause()}catch{}
  v.srcObject=null;
  if(stream){stream.getTracks().forEach(t=>t.stop()); stream=null}
  setState('idle'); log('C√°mara cerrada');
}

/* ---------- capturar y procesar ---------- */
function captureNow(silent=false){
  if(!v.videoWidth){ if(!silent) alert('La c√°mara a√∫n no est√° lista'); return }
  const c=document.createElement('canvas'); c.width=v.videoWidth; c.height=v.videoHeight;
  c.getContext('2d').drawImage(v,0,0,c.width,c.height);
  captured=c.toDataURL('image/jpeg',0.92);
  guide.pxPerMm = ocvLast?.found ? (ocvLast.longSidePx/CR80_W) : null;
  closeCam(); shot.src=captured; shot.style.display='block';
  badge.style.display='none'; meter.style.display='none';
}

async function processNow(){
  try{
    if(!captured){
      if(stream){ log('No hay foto: capturo y proceso‚Ä¶'); captureNow(true) }
      else{ alert('Primero captura o sube una foto.'); return }
    }
    const img=await new Promise((res,rej)=>{ const im=new Image(); im.src=captured; im.onload=()=>res(im); im.onerror=rej });
    let pxmm=guide.pxPerMm;
    if(!pxmm){ const approxW=Math.min(img.width,img.height)*0.22; pxmm=approxW/CR80_W; scaleSrcEl.textContent='Estimaci√≥n' }
    else{ scaleSrcEl.textContent='ROI OpenCV (gu√≠a)' }
    pxmmEl.textContent=pxmm.toFixed(3);

    // landmarks
    let L=null;
    if(window.FaceMesh){
      const fm=new window.FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
      fm.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
      L=await new Promise(resolve=>{
        const c=document.createElement('canvas'); c.width=img.width; c.height=img.height;
        c.getContext('2d').drawImage(img,0,0);
        fm.onResults(r=>{
          if(r.multiFaceLandmarks && r.multiFaceLandmarks[0]){
            const lm=r.multiFaceLandmarks[0];
            const iris=(a)=>({x:a.reduce((s,l)=>s+l.x*img.width,0)/a.length, y:a.reduce((s,l)=>s+l.y*img.height,0)/a.length});
            resolve({left:iris(lm.slice(473,477)), right:iris(lm.slice(468,472))});
          }else resolve(null);
        });
        fm.send({image:c});
      });
    }
    if(!L){ const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15/2; L={left:{x:cx-d,y:cy}, right:{x:cx+d,y:cy}} }

    const dx=L.right.x-L.left.x, dy=L.right.y-L.left.y;
    const ipd=Math.round((Math.hypot(dx,dy)/pxmm)*10)/10;
    ipdEl.textContent=ipd+' mm';

    const outC=document.createElement('canvas'); outC.width=img.width; outC.height=img.height;
    const a=outC.getContext('2d'); a.drawImage(img,0,0);
    a.fillStyle='#ff0000';
    a.beginPath(); a.arc(L.left.x,L.left.y,10,0,Math.PI*2); a.fill();
    a.beginPath(); a.arc(L.right.x,L.right.y,10,0,Math.PI*2); a.fill();
    a.strokeStyle='#ff0000'; a.lineWidth=4; a.beginPath(); a.moveTo(L.left.x,L.left.y); a.lineTo(L.right.x,L.right.y); a.stroke();
    a.font='bold 36px system-ui,-apple-system'; a.fillStyle='#fff'; a.strokeStyle='#000'; a.lineWidth=6;
    const mx=(L.left.x+L.right.x)/2, my=(L.left.y+L.right.y)-28;
    a.strokeText(`IPD: ${ipd} mm`, mx-110, my); a.fillText(`IPD: ${ipd} mm`, mx-110, my);
    const url=outC.toDataURL('image/png');

    finalImg.src=url; dl.href=url; out.style.display='block';
    log('Procesado OK ‚Äî IPD '+ipd+' mm');
  }catch(e){ log('Error procesar: '+e.message); alert('No se pudo procesar: '+e.message) }
}

/* ---------- eventos ---------- */
btnOpen.onclick=openCam;
btnClose.onclick=closeCam;
btnCapture.onclick=()=>captureNow(false);
btnProcess.onclick=processNow;

pickBtn.onclick=()=>fileIn.click();
fileIn.onchange=(e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const rd=new FileReader(); rd.onload=ev=>{
    captured=ev.target.result; shot.src=captured; shot.style.display='block';
    closeCam(); badge.style.display='none'; meter.style.display='none'; guide.pxPerMm=null;
    log('Imagen cargada desde galer√≠a');
  }; rd.readAsDataURL(f);
};
</script>
</body>
</html>