<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Medidor √ìptico Facial ‚Äî C√°mara + Gu√≠a CR80</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 UMD + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- OpenCV (opcional) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    html,body{background:#eef2ff}
    video.cam{width:100%;height:auto;max-height:64vh;background:#000;border-radius:.75rem;object-fit:cover}
    canvas.ov{position:absolute;inset:0;pointer-events:none;border-radius:.75rem}
    .tag{font-variant-numeric:tabular-nums}
    .dbg{position:fixed;top:8px;right:8px;background:#0f172a;color:#fff;font:12px/1.2 system-ui,-apple-system;padding:8px 10px;border-radius:8px;opacity:.85;z-index:50}
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {useState,useEffect,useRef} = React;
const CR80_W=85.60, CR80_H=53.98, CR80_AR=CR80_W/CR80_H;

function App(){
  const [dbg,setDbg]=useState('');
  const [state,setState]=useState('idle'); // idle|ready|captured|error
  const [image,setImage]=useState(null);
  const [annotated,setAnnotated]=useState(null);
  const [autoCapture,setAutoCapture]=useState(true);
  const [useGuide,setUseGuide]=useState(true);
  const [ipd,setIpd]=useState(null);
  const [pxmm,setPxmm]=useState(null);
  const [method,setMethod]=useState('‚Äî');

  const vRef=useRef(null);
  const streamRef=useRef(null);
  const cRef=useRef(null);
  const rafRef=useRef(0);
  const ocvLast=useRef({found:false,score:0,long:0});
  const [edgePct,setEdgePct]=useState(0);
  const [ocvPct,setOcvPct]=useState(0);

  // FaceMesh
  useEffect(()=>{
    const init=()=>{
      try{
        const fm=new window.FaceMesh({ locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
        fm.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
        window.__fm=fm;
        setDbg(d=>d+' | fm:ready');
      }catch(e){ setDbg(d=>d+' | fm:err'); }
    };
    if(typeof window.FaceMesh==='undefined'){
      const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js'; s.async=true;
      s.onload=()=>{ const u=document.createElement('script'); u.src='https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js'; u.async=true; u.onload=init; document.body.appendChild(u); };
      document.body.appendChild(s);
    }else init();
  },[]);

  const hasMedia = () => !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);

  const stopStream=()=>{
    cancelAnimationFrame(rafRef.current);
    const v=vRef.current; if(v){ v.pause(); v.srcObject=null; }
    if(streamRef.current){ try{streamRef.current.getTracks().forEach(t=>t.stop());}catch{} streamRef.current=null; }
  };

  const startCam = async () => {
    // todo dentro del mismo handler del click
    try{
      setDbg(`clk cam | secure:${location.protocol==='https:'} | media:${!!navigator.mediaDevices}`);
      if(!hasMedia()){ setState('error'); return setDbg(d=>d+' | no mediaDevices'); }

      // cerrar cualquier stream previo
      stopStream();

      const v=vRef.current;
      v.setAttribute('playsinline',''); v.setAttribute('autoplay',''); v.muted=true; v.playsInline=true;

      // NO usar await antes de play(); pedir el stream y en .then establecer y play()
      navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:'user'}, width:{ideal:1280}, height:{ideal:720} },
        audio:false
      }).then(stream=>{
        streamRef.current=stream;
        v.srcObject=stream;
        // play en el mismo tick sincronizado al gesture del usuario
        const p=v.play();
        if(p && typeof p.then==='function'){
          p.then(()=> setDbg(d=>d+' | play ok')).catch(e=> setDbg(d=>d+' | play err:'+e.message));
        }
        setState('ready');
        startOverlayLoop();
      }).catch(err=>{
        setState('error');
        setDbg(d=>d+` | gum err:${err.name}`);
      });
    }catch(e){
      setState('error'); setDbg(d=>d+` | start err:${e.message}`);
    }
  };

  const roiBox = ()=>{
    const v=vRef.current; if(!v || !v.videoWidth) return null;
    const vw=v.videoWidth, vh=v.videoHeight;
    const w=Math.round(Math.min(vw*0.42, 360));
    const h=Math.round(w/CR80_AR);
    const cx=Math.round(vw/2), cy=Math.round(vh*0.62);
    return {x:cx-Math.round(w/2), y:cy-Math.round(h/2), w, h};
  };

  function ocvDetect(imageData, gw, gh){
    const cv=window.cv; if(!cv || !cv.Mat) return null;
    try{
      const src=cv.matFromImageData(imageData);
      const gray=new cv.Mat(), blur=new cv.Mat(), edges=new cv.Mat();
      cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
      let sum=0; const d=blur.data; for(let i=0;i<d.length;i++) sum+=d[i];
      const mean=sum/d.length; const low=Math.max(0,0.66*mean), high=Math.min(255,1.33*mean);
      cv.Canny(blur,edges,low,high);
      const contours=new cv.MatVector(), hier=new cv.Mat();
      cv.findContours(edges,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
      let best=null, bestScore=0;
      for(let i=0;i<contours.size();i++){
        const cnt=contours.get(i);
        const area=cv.contourArea(cnt); if(area < (gw*gh)*0.12){ cnt.delete(); continue; }
        const peri=cv.arcLength(cnt,true);
        const approx=new cv.Mat(); cv.approxPolyDP(cnt,approx,0.02*peri,true);
        if(approx.rows===4){
          const r=cv.minAreaRect(cnt);
          const L=Math.max(r.size.width,r.size.height), S=Math.min(r.size.width,r.size.height);
          const ar=L/S;
          const aspectScore=Math.max(0,1-Math.min(Math.abs(ar-CR80_AR)/0.35,1));
          const fillScore=Math.min(1,(area/(gw*gh))*2.0);
          const score=aspectScore*0.7 + fillScore*0.3;
          if(score>bestScore){ bestScore=score; best={found:true,long:L,score}; }
        }
        approx.delete(); cnt.delete();
      }
      gray.delete(); blur.delete(); edges.delete(); contours.delete(); hier.delete(); src.delete();
      return best || {found:false,score:0,long:0};
    }catch{ return null; }
  }

  const startOverlayLoop=()=>{
    const v=vRef.current, c=cRef.current;
    const ctx=c.getContext('2d', {willReadFrequently:true});
    let frame=0;

    const loop=()=>{
      if(!v || !v.videoWidth){ rafRef.current=requestAnimationFrame(loop); return; }
      c.width=v.videoWidth; c.height=v.videoHeight;

      // frame espejo de fondo
      ctx.save(); ctx.scale(-1,1); ctx.drawImage(v,-c.width,0,c.width,c.height); ctx.restore();

      // m√°scara gris
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,c.width,c.height);

      const roi=roiBox();
      if(roi){
        const {x,y,w,h}=roi;
        ctx.clearRect(x,y,w,h); // ‚Äúagujero‚Äù
        // borde
        const img=ctx.getImageData(x,y,w,h);
        const k=3; let edge=0, tot=0;
        for(let yy=0; yy<h; yy++){
          for(let xx=0; xx<w; xx++){
            const onB=(yy<k)||(yy>=h-k)||(xx<k)||(xx>=w-k);
            if(!onB) continue;
            const i=(yy*w+xx)*4, r=img.data[i], g=img.data[i+1], b=img.data[i+2];
            const lum=0.299*r+0.587*g+0.114*b;
            if(lum<70 || lum>210) edge++; tot++;
          }
        }
        const edgeScore=tot? edge/tot : 0; setEdgePct(edgeScore);

        if(frame%3===0){
          const r=ocvDetect(img,w,h);
          if(r){ ocvLast.current=r; setOcvPct(r.found?r.score:0); }
        }
        frame++;

        const combined=Math.max(edgeScore, ocvPct);
        ctx.strokeStyle= combined>=0.7 ? '#22c55e' : '#a78bfa';
        ctx.lineWidth=4; ctx.strokeRect(x,y,w,h);
        ctx.font='bold 18px system-ui,-apple-system'; ctx.fillStyle='#fff';
        ctx.fillText(`Gu√≠a CR80 ‚Äî Match ${Math.round(combined*100)}%`, Math.max(12,x), Math.max(24,y-10));

        // autocaptura solo si OpenCV ve tarjeta con score >= 0.7
        if(autoCapture && ocvLast.current.found && ocvLast.current.score>=0.7){
          captureFromVideo();
          return;
        }
      }
      rafRef.current=requestAnimationFrame(loop);
    };

    cancelAnimationFrame(rafRef.current);
    rafRef.current=requestAnimationFrame(loop);
  };

  const captureFromVideo=()=>{
    const v=vRef.current; if(!v || !v.videoWidth) return;
    // fijar escala si tenemos tarjeta
    if(useGuide && ocvLast.current.found){
      setPxmm(ocvLast.current.long/CR80_W);
    }
    // congelar
    const shot=document.createElement('canvas'); shot.width=v.videoWidth; shot.height=v.videoHeight;
    shot.getContext('2d').drawImage(v,0,0,shot.width,shot.height);
    setImage(shot.toDataURL('image/jpeg',0.92));

    stopStream();
    setState('captured');
    process(); // sigue a procesamiento
  };

  const process=async()=>{
    if(!image) return;
    try{
      const img=await new Promise((res,rej)=>{ const m=new Image(); m.src=image; m.onload=()=>res(m); m.onerror=rej; });
      let scale = pxmm || (ocvLast.current.found ? ocvLast.current.long/CR80_W : null);
      if(!scale){ // fallback
        const w = Math.min(img.width,img.height)*0.42;
        scale = w / CR80_W;
      }
      const lm = await new Promise(resolve=>{
        if(window.__fm){
          const c=document.createElement('canvas'); c.width=img.width; c.height=img.height;
          c.getContext('2d').drawImage(img,0,0);
          window.__fm.onResults(r=>{
            if(r.multiFaceLandmarks && r.multiFaceLandmarks[0]){
              const L=r.multiFaceLandmarks[0];
              const iris=(a)=>({x:a.reduce((s,l)=>s+l.x*img.width,0)/a.length,y:a.reduce((s,l)=>s+l.y*img.height,0)/a.length});
              resolve({left:iris(L.slice(473,477)), right:iris(L.slice(468,472)), method:'MediaPipe'});
            }else{
              const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
              resolve({left:{x:cx-d/2,y:cy}, right:{x:cx+d/2,y:cy}, method:'Estimaci√≥n'});
            }
          });
          window.__fm.send({image:c});
        }else{
          const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
          resolve({left:{x:cx-d/2,y:cy}, right:{x:cx+d/2,y:cy}, method:'Estimaci√≥n'});
        }
      });
      setMethod(lm.method);
      const d=Math.hypot(lm.right.x-lm.left.x, lm.right.y-lm.left.y);
      const ipd_mm=Math.round((d/scale)*10)/10; setIpd(ipd_mm);

      // anotaci√≥n
      const out=document.createElement('canvas'); out.width=img.width; out.height=img.height;
      const a=out.getContext('2d'); a.drawImage(img,0,0);
      a.fillStyle='#f00';
      a.beginPath(); a.arc(lm.left.x,lm.left.y,10,0,Math.PI*2); a.fill();
      a.beginPath(); a.arc(lm.right.x,lm.right.y,10,0,Math.PI*2); a.fill();
      a.strokeStyle='#f00'; a.lineWidth=4; a.beginPath();
      a.moveTo(lm.left.x,lm.left.y); a.lineTo(lm.right.x,lm.right.y); a.stroke();
      a.font='bold 26px system-ui,-apple-system'; a.fillStyle='#fff'; a.strokeStyle='#000'; a.lineWidth=6;
      const mx=(lm.left.x+lm.right.x)/2, my=(lm.left.y+lm.right.y)/2 - 22;
      a.strokeText(`IPD: ${ipd_mm} mm`, mx-90, my); a.fillText(`IPD: ${ipd_mm} mm`, mx-90, my);
      setAnnotated(out.toDataURL('image/png'));
    }catch(e){ setDbg(d=>d+' | proc err:'+e.message); }
  };

  const onUpload=e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const r=new FileReader();
    r.onload=ev=>{ setImage(ev.target.result); setState('captured'); process(); };
    r.readAsDataURL(f);
  };

  return (
    <div className="min-h-screen p-4">
      <div className="dbg">estado:{state} ‚Ä¢ {dbg}</div>
      <div className="max-w-3xl mx-auto space-y-4">
        <div className="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-500">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl font-bold">Medidor √ìptico Facial</h1>
              <p className="text-slate-600">C√°mara embebida + Gu√≠a CR80</p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-2xl shadow p-5">
          <h2 className="text-xl font-semibold mb-3">Captura de Imagen</h2>

          <div className="grid grid-cols-2 gap-3 mb-3">
            <label className="inline-flex items-center justify-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 rounded-xl cursor-pointer">
              üñºÔ∏è <span>Subir Foto</span>
              <input type="file" accept="image/*" className="hidden" onChange={onUpload} />
            </label>

            {state!=='ready' ? (
              <button type="button" onClick={startCam}
                className="inline-flex items-center justify-center gap-2 bg-violet-600 hover:bg-violet-700 text-white font-semibold py-3 rounded-xl">
                üì∑ C√°mara
              </button>
            ) : (
              <button type="button" onClick={()=>{ stopStream(); setState('idle'); }}
                className="inline-flex items-center justify-center gap-2 bg-rose-600 hover:bg-rose-700 text-white font-semibold py-3 rounded-xl">
                üõë Cerrar
              </button>
            )}
          </div>

          {/* Fallback nativo del sistema (abre UI de c√°mara de iOS/Android) */}
          <div className="mb-4">
            <label className="text-sm text-slate-600 underline cursor-pointer">
              Usar c√°mara del sistema (fallback)
              <input type="file" accept="image/*" capture="user" className="hidden" onChange={onUpload}/>
            </label>
          </div>

          {state==='ready' && (
            <div className="relative">
              <video ref={vRef} className="cam" autoplay playsinline muted></video>
              <canvas ref={cRef} className="ov"></canvas>

              <div className="mt-3 flex items-center gap-3 flex-wrap">
                <label className="inline-flex items-center gap-2">
                  <input type="checkbox" className="scale-110" checked={useGuide} onChange={e=>setUseGuide(e.target.checked)}/>
                  <span>Usar Gu√≠a CR80</span>
                </label>

                <label className="inline-flex items-center gap-2">
                  <input type="checkbox" className="scale-110" checked={autoCapture} onChange={e=>setAutoCapture(e.target.checked)}/>
                  <span>Auto-capturar (‚â•70% con tarjeta)</span>
                </label>

                <button type="button" onClick={captureFromVideo}
                        className="ml-auto inline-flex items-center justify-center gap-2 px-4 py-2 rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-semibold">
                  üì∏ Capturar
                </button>
              </div>

              <div className="text-xs text-slate-600 mt-2">
                Match: <b className="tag">{Math.round(Math.max(edgePct,ocvPct)*100)}%</b> ‚Ä¢ OpenCV: <b className="tag">{Math.round(ocvPct*100)}%</b>
              </div>
            </div>
          )}
        </div>

        {image && (
          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Imagen Capturada</h3>
            <img src={image} alt="capturada" className="w-full rounded-lg shadow"/>
            <div className="mt-3 grid sm:grid-cols-3 gap-3">
              <div className="p-3 rounded bg-indigo-50">
                <div className="text-xs text-slate-600">IPD</div>
                <div className="text-3xl font-bold">{ipd ?? '‚Äî'} {ipd && 'mm'}</div>
              </div>
              <div className="p-3 rounded bg-violet-50">
                <div className="text-xs text-slate-600">Escala (px/mm)</div>
                <div className="text-xl font-semibold tag">{pxmm?.toFixed ? pxmm.toFixed(3) : '‚Äî'}</div>
              </div>
              <div className="p-3 rounded bg-emerald-50">
                <div className="text-xs text-slate-600">M√©todo</div>
                <div className="text-lg font-semibold">{method}</div>
              </div>
            </div>
            {annotated && <img src={annotated} className="w-full rounded-lg shadow mt-3" alt="anotada"/>}
          </div>
        )}

        <div className="text-center text-xs text-slate-500 py-4">¬© 2025 ‚Äî C√°mara + Gu√≠a CR80</div>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>