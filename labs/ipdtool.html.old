<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Medidor √ìptico Facial</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 UMD + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- OpenCV.js (para detecci√≥n robusta de tarjeta) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- Estilos m√≠nimos extra -->
  <style>
    html,body { background: #eef2ff; }
    .hidden-canvas { display:none; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const {useState,useRef,useEffect} = React;

    // ---- √çCONOS LIGEROS (placeholder, sin dependencias) ----
    const IconWrap = ({children, className=""}) =>
      <span className={"inline-flex items-center justify-center " + className} style={{width: '1.25rem', height: '1.25rem'}}>{children}</span>;
    const Camera = (p)=> <IconWrap {...p}>üì∑</IconWrap>;
    const Upload = (p)=> <IconWrap {...p}>üîº</IconWrap>;
    const Eye = (p)=> <IconWrap {...p}>üëÅÔ∏è</IconWrap>;
    const Ruler = (p)=> <IconWrap {...p}>üìè</IconWrap>;
    const AlertCircle = (p)=> <IconWrap {...p}>‚ö†Ô∏è</IconWrap>;
    const CheckCircle = (p)=> <IconWrap {...p}>‚úÖ</IconWrap>;
    const Download = (p)=> <IconWrap {...p}>‚¨áÔ∏è</IconWrap>;
    const Info = (p)=> <IconWrap {...p}>‚ÑπÔ∏è</IconWrap>;
    const Zap = (p)=> <IconWrap {...p}>‚ö°</IconWrap>;
    const Loader = (p)=> <IconWrap {...p} className={(p.className||"")+" animate-spin"}>‚è≥</IconWrap>;

    // ---- Constantes ----
    const CR80_WIDTH = 85.60;
    const CR80_HEIGHT = 53.98;
    const REFERENCE_MEASUREMENTS = [
      { label: "Ref 1", value: 60.11 },
      { label: "Ref 2", value: 45.72 },
      { label: "Ref 3", value: 37.94 },
      { label: "Ref 4", value: 47.49 },
      { label: "Ref 5", value: 18.37 },
      { label: "Ref 6", value: 30.90 },
      { label: "Ref 7", value: 26.90 },
      { label: "Ref 8", value: 29.90 }
    ];

    // ---- Utilidad ----
    const dist = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

    // ---- Detecci√≥n de tarjeta con OpenCV (cuadril√°tero rotado) ----
    const detectCardWithOpenCV = (canvas) => {
      try {
        if (!window.cv || !cv.Mat) return { found:false };
        const src = cv.imread(canvas);
        const ratio = CR80_WIDTH / CR80_HEIGHT; // 1.586

        let gray = new cv.Mat(), blur = new cv.Mat(), edges = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

        // Umbrales Canny aproximados por luminancia media (robusto)
        let sum = 0; const data = blur.data; for (let i=0;i<data.length;i++) sum += data[i];
        const mean = sum / data.length;
        const lower = Math.max(0, 0.66*mean), upper = Math.min(255, 1.33*mean);
        cv.Canny(blur, edges, lower, upper);

        // Cerrar cortes
        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
        cv.dilate(edges, edges, kernel);

        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let best = null, bestScore = 0;

        for (let i=0; i<contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area < (src.rows*src.cols)*0.002) { cnt.delete(); continue; }

          const peri = cv.arcLength(cnt, true);
          const approx = new cv.Mat();
          cv.approxPolyDP(cnt, approx, 0.02*peri, true);

          if (approx.rows === 4) {
            const rect = cv.minAreaRect(cnt);
            const w = rect.size.width, h = rect.size.height;
            const longSide = Math.max(w,h), shortSide = Math.min(w,h);
            const ar = longSide / shortSide;
            if (Math.abs(ar - ratio) <= ratio * 0.15) {
              const angle = rect.angle; // [-90,0)
              const score = (area/(src.rows*src.cols))*0.8 + (1 - Math.min(Math.abs(angle)/90,1))*0.2;

              if (score > bestScore) {
                const pts = cv.RotatedRect.points(rect);
                const corners = pts.map(p=>({x:p.x,y:p.y}));
                best = {
                  found: true,
                  corners,
                  longSidePx: longSide,
                  shortSidePx: shortSide,
                  angle,
                  confidence: Math.min(0.95, score*2.0)
                };
                bestScore = score;
              }
            }
          }
          approx.delete(); cnt.delete();
        }

        gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete(); src.delete();
        return best || {found:false};
      } catch (e) {
        console.log("OpenCV error:", e);
        return {found:false};
      }
    };

    // ---- Face fallback geom√©trico ----
    const detectFaceWithFallback = (width, height) => {
      const centerX = width/2;
      const centerY = height*0.45;
      const estimatedIPDpx = width * 0.15;
      const rightPupil = { x: centerX + estimatedIPDpx/2, y: centerY };
      const leftPupil  = { x: centerX - estimatedIPDpx/2, y: centerY };
      return {
        rightPupil, leftPupil,
        noseTip: { x:centerX, y:centerY + height*0.08 },
        chinBottom: { x:centerX, y:centerY + height*0.25 },
        faceCenter: { x:centerX, y:centerY },
        confidence: 0.65, method: "Estimaci√≥n"
      };
    };

    const OpticalMeasurementApp = () => {
      const [image, setImage] = useState(null);
      const [processing, setProcessing] = useState(false);
      const [results, setResults] = useState(null);
      const [error, setError] = useState(null);
      const [annotatedImage, setAnnotatedImage] = useState(null);
      const [processingStep, setProcessingStep] = useState("");
      const [faceMeshReady, setFaceMeshReady] = useState(false);
      const [loadingModels, setLoadingModels] = useState(true);

      const canvasRef = useRef(null);
      const fileInputRef = useRef(null);
      const videoRef = useRef(null);
      const [cameraActive, setCameraActive] = useState(false);
      const faceMeshRef = useRef(null);

      // ---- MediaPipe FaceMesh ----
      useEffect(() => {
        const loadFaceMesh = async () => {
          try {
            setProcessingStep("Cargando modelos de detecci√≥n facial‚Ä¶");

            const initializeFaceMesh = () => {
              try {
                const faceMesh = new window.FaceMesh({
                  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                faceMesh.setOptions({
                  maxNumFaces: 1,
                  refineLandmarks: true,
                  minDetectionConfidence: 0.5,
                  minTrackingConfidence: 0.5
                });
                faceMeshRef.current = faceMesh;
                setFaceMeshReady(true);
                setLoadingModels(false);
                setProcessingStep("");
              } catch (err) {
                console.error("Error initializing face mesh:", err);
                setFaceMeshReady(false);
                setLoadingModels(false);
                setProcessingStep("");
              }
            };

            if (typeof window.FaceMesh === "undefined") {
              const script = document.createElement("script");
              script.src = "https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js";
              script.async = true;
              script.onload = () => {
                const cameraUtilsScript = document.createElement("script");
                cameraUtilsScript.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";
                cameraUtilsScript.async = true;
                cameraUtilsScript.onload = () => initializeFaceMesh();
                cameraUtilsScript.onerror = () => {
                  console.log("MediaPipe not available, using fallback method");
                  setFaceMeshReady(false);
                  setLoadingModels(false);
                  setProcessingStep("");
                };
                document.body.appendChild(cameraUtilsScript);
              };
              script.onerror = () => {
                console.log("MediaPipe not available, using fallback method");
                setFaceMeshReady(false);
                setLoadingModels(false);
                setProcessingStep("");
              };
              document.body.appendChild(script);
            } else {
              initializeFaceMesh();
            }
          } catch (err) {
            console.error("Error loading face mesh:", err);
            setFaceMeshReady(false);
            setLoadingModels(false);
            setProcessingStep("");
          }
        };
        loadFaceMesh();
      }, []);

      // ---- Upload / C√°mara ----
      const handleImageUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            setImage(event.target.result);
            setResults(null);
            setError(null);
            setAnnotatedImage(null);
          };
          reader.readAsDataURL(file);
        }
      };

      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user", width: 1280, height: 720 },
            audio: false
          });
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            await videoRef.current.play();
            setCameraActive(true);
          }
        } catch (err) {
          setError("No se pudo acceder a la c√°mara: " + err.message);
        }
      };

      const stopCamera = () => {
        if (videoRef.current && videoRef.current.srcObject) {
          videoRef.current.srcObject.getTracks().forEach(t => t.stop());
          setCameraActive(false);
        }
      };

      const capturePhoto = () => {
        if (videoRef.current) {
          const canvas = document.createElement("canvas");
          canvas.width = videoRef.current.videoWidth;
          canvas.height = videoRef.current.videoHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(videoRef.current, 0, 0);
          const dataUrl = canvas.toDataURL("image/jpeg");
          setImage(dataUrl);
          stopCamera();
          setResults(null);
          setError(null);
          setAnnotatedImage(null);
        }
      };

      // ---- Detecci√≥n de tarjeta (OpenCV) ----
      const detectCardReal = (ctx, width, height) => {
        setProcessingStep("Detectando tarjeta CR80‚Ä¶");
        // Preferir OpenCV
        const res = detectCardWithOpenCV(ctx.canvas);
        if (res.found) return res;
        // Fallback b√°sico (sin detecci√≥n): forzar error m√°s adelante
        return { found:false };
      };

      // ---- Detecci√≥n facial ----
      const detectFaceWithMediaPipe = async (img) => {
        return new Promise((resolve, reject) => {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);

          faceMeshRef.current.onResults((results) => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks[0]) {
              const landmarks = results.multiFaceLandmarks[0];

              const rightIris = landmarks.slice(468,472);
              const rightPupil = {
                x: rightIris.reduce((s,l)=> s + l.x*img.width, 0)/4,
                y: rightIris.reduce((s,l)=> s + l.y*img.height,0)/4
              };
              const leftIris = landmarks.slice(473,477);
              const leftPupil = {
                x: leftIris.reduce((s,l)=> s + l.x*img.width, 0)/4,
                y: leftIris.reduce((s,l)=> s + l.y*img.height,0)/4
              };
              const noseTip = { x: landmarks[1].x*img.width, y: landmarks[1].y*img.height };
              const chinBottom = { x: landmarks[152].x*img.width, y: landmarks[152].y*img.height };

              resolve({
                rightPupil,leftPupil,noseTip,chinBottom,
                faceCenter: { x:(rightPupil.x+leftPupil.x)/2, y:(rightPupil.y+leftPupil.y)/2 },
                confidence: 0.95, method: "MediaPipe"
              });
            } else {
              reject(new Error("No se detect√≥ rostro en la imagen"));
            }
          });

          faceMeshRef.current.send({ image: canvas });
        });
      };

      const detectFaceReal = async (img, width, height) => {
        setProcessingStep("Detectando rostro y pupilas‚Ä¶");
        if (faceMeshReady && faceMeshRef.current) {
          try { return await detectFaceWithMediaPipe(img); }
          catch { return detectFaceWithFallback(width, height); }
        }
        return detectFaceWithFallback(width, height);
      };

      // ---- Detecci√≥n de armaz√≥n (simple, como tu l√≥gica) ----
      const detectFrameReal = (ctx, landmarks, width, height) => {
        setProcessingStep("Detectando armaz√≥n‚Ä¶");
        const imageData = ctx.getImageData(0,0,width,height);
        const data = imageData.data;
        const {rightPupil,leftPupil} = landmarks;

        const searchRadius = Math.abs(rightPupil.x - leftPupil.x) * 0.8;
        let darkPixelCount = 0;
        const samples = 200;
        for (let i=0;i<samples;i++) {
          const angle = (Math.PI*2*i)/samples;
          const x = Math.floor(rightPupil.x + Math.cos(angle)*searchRadius);
          const y = Math.floor(rightPupil.y + Math.sin(angle)*searchRadius);
          if (x>=0 && x<width && y>=0 && y<height) {
            const idx = (y*width + x)*4;
            const brightness = (data[idx] + data[idx+1] + data[idx+2])/3;
            if (brightness < 80) darkPixelCount++;
          }
        }
        const framePresent = darkPixelCount > samples*0.15;
        if (!framePresent) return {found:false};

        const frameWidth = Math.abs(rightPupil.x - leftPupil.x) * 1.8;
        const lensWidth = frameWidth * 0.42;
        const lensHeight = lensWidth * 0.85;
        const bridge = frameWidth * 0.16;

        return {
          found: true,
          centerX: (rightPupil.x + leftPupil.x)/2,
          bridge,
          rightLens: {
            center: {x:rightPupil.x, y:rightPupil.y},
            width: lensWidth, height: lensHeight,
            top: rightPupil.y - lensHeight/2,
            bottom: rightPupil.y + lensHeight/2
          },
          leftLens: {
            center: {x:leftPupil.x, y:leftPupil.y},
            width: lensWidth, height: lensHeight,
            top: leftPupil.y - lensHeight/2,
            bottom: leftPupil.y + lensHeight/2
          },
          confidence: 0.75
        };
      };

      const calculateMeasurements = (card, landmarks, frame, pxPerMm) => {
        setProcessingStep("Calculando mediciones‚Ä¶");
        const {rightPupil,leftPupil} = landmarks;
        const diPx = Math.hypot(rightPupil.x-leftPupil.x, rightPupil.y-leftPupil.y);
        const DI_mm = diPx / pxPerMm;

        let measurements = {
          DI_mm: Math.round(DI_mm*10)/10,
          A_right_mm: null, A_left_mm: null,
          B_right_mm: null, B_left_mm: null,
          extras: {
            bridge_mm: null,
            lens_right_width_mm: null, lens_left_width_mm: null,
            lens_right_height_mm: null, lens_left_height_mm: null
          }
        };

        if (frame.found) {
          const A_right_px = Math.abs(rightPupil.x - frame.centerX);
          const A_left_px  = Math.abs(leftPupil.x  - frame.centerX);
          measurements.A_right_mm = Math.round((A_right_px/pxPerMm)*10)/10;
          measurements.A_left_mm  = Math.round((A_left_px /pxPerMm)*10)/10;

          const B_right_px = Math.abs(frame.rightLens.bottom - rightPupil.y);
          const B_left_px  = Math.abs(frame.leftLens.bottom  - leftPupil.y);
          measurements.B_right_mm = Math.round((B_right_px/pxPerMm)*10)/10;
          measurements.B_left_mm  = Math.round((B_left_px /pxPerMm)*10)/10;

          measurements.extras.bridge_mm = Math.round((frame.bridge/pxPerMm)*10)/10;
          measurements.extras.lens_right_width_mm  = Math.round((frame.rightLens.width /pxPerMm)*10)/10;
          measurements.extras.lens_left_width_mm   = Math.round((frame.leftLens.width  /pxPerMm)*10)/10;
          measurements.extras.lens_right_height_mm = Math.round((frame.rightLens.height/pxPerMm)*10)/10;
          measurements.extras.lens_left_height_mm  = Math.round((frame.leftLens.height /pxPerMm)*10)/10;
        }
        return measurements;
      };

      const createAnnotatedImage = (ctx, img, card, landmarks, frame, measurements, pxPerMm) => {
        setProcessingStep("Generando imagen anotada‚Ä¶");
        const annotCanvas = document.createElement("canvas");
        annotCanvas.width = img.width; annotCanvas.height = img.height;
        const a = annotCanvas.getContext("2d");
        a.drawImage(img, 0, 0);

        // Tarjeta
        if (card.found && card.corners) {
          a.strokeStyle = "#00ff00"; a.lineWidth = 4; a.beginPath();
          a.moveTo(card.corners[0].x, card.corners[0].y);
          for (let i=1;i<card.corners.length;i++) a.lineTo(card.corners[i].x, card.corners[i].y);
          a.closePath(); a.stroke();
          a.fillStyle = "#00ff00"; a.font = "bold 16px Arial";
          a.strokeStyle="#000"; a.lineWidth=3;
          a.strokeText("CR80 Card", card.corners[0].x+10, card.corners[0].y+25);
          a.fillText("CR80 Card", card.corners[0].x+10, card.corners[0].y+25);
        }

        // Pupilas + l√≠nea IPD
        const {rightPupil,leftPupil} = landmarks;
        a.fillStyle = "#ff0000";
        a.beginPath(); a.arc(rightPupil.x,rightPupil.y,10,0,Math.PI*2); a.fill();
        a.beginPath(); a.arc(leftPupil.x,leftPupil.y,10,0,Math.PI*2); a.fill();

        a.strokeStyle="#ff0000"; a.lineWidth=3; a.beginPath();
        a.moveTo(leftPupil.x,leftPupil.y); a.lineTo(rightPupil.x,rightPupil.y); a.stroke();

        // Etiquetas
        const diMidX = (leftPupil.x+rightPupil.x)/2;
        const diMidY = (leftPupil.y+rightPupil.y)/2 - 20;
        a.fillStyle="#fff"; a.strokeStyle="#000"; a.lineWidth=4; a.font="bold 18px Arial";
        const diText = `IPD/DI: ${measurements.DI_mm} mm`;
        a.strokeText(diText, diMidX-70, diMidY); a.fillText(diText, diMidX-70, diMidY);

        a.font="bold 14px Arial"; a.fillStyle="#ffff00"; a.strokeStyle="#000"; a.lineWidth=3;
        const methodText = `M√©todo: ${landmarks.method}`;
        a.strokeText(methodText, diMidX-60, diMidY+25); a.fillText(methodText, diMidX-60, diMidY+25);

        if (frame.found) {
          a.strokeStyle="#00ffff"; a.lineWidth=2; a.setLineDash([10,5]);
          a.beginPath(); a.moveTo(frame.centerX, rightPupil.y-120); a.lineTo(frame.centerX, rightPupil.y+120); a.stroke();
          a.setLineDash([]);

          a.strokeStyle="#fff"; a.lineWidth=2;
          a.strokeRect(frame.rightLens.center.x - frame.rightLens.width/2, frame.rightLens.top, frame.rightLens.width, frame.rightLens.height);
          a.strokeRect(frame.leftLens.center.x  - frame.leftLens.width/2,  frame.leftLens.top,  frame.leftLens.width,  frame.leftLens.height);

          a.strokeStyle="#0088ff"; a.lineWidth=3;
          a.beginPath(); a.moveTo(rightPupil.x, rightPupil.y+30); a.lineTo(frame.centerX, rightPupil.y+30); a.stroke();
          a.fillStyle="#fff"; a.strokeStyle="#000"; a.lineWidth=3; a.font="bold 14px Arial";
          const aRightMid = (rightPupil.x + frame.centerX)/2;
          a.strokeText(`A: ${measurements.A_right_mm}mm`, aRightMid-30, rightPupil.y+50);
          a.fillText(`A: ${measurements.A_right_mm}mm`, aRightMid-30, rightPupil.y+50);

          a.strokeStyle="#0088ff"; a.lineWidth=3;
          a.beginPath(); a.moveTo(leftPupil.x, leftPupil.y+30); a.lineTo(frame.centerX, leftPupil.y+30); a.stroke();
          const aLeftMid = (leftPupil.x + frame.centerX)/2;
          a.strokeText(`A: ${measurements.A_left_mm}mm`, aLeftMid-30, leftPupil.y+50);
          a.fillText(`A: ${measurements.A_left_mm}mm`, aLeftMid-30, leftPupil.y+50);

          a.strokeStyle="#ffff00"; a.lineWidth=3;
          a.beginPath(); a.moveTo(rightPupil.x+35, rightPupil.y); a.lineTo(rightPupil.x+35, frame.rightLens.bottom); a.stroke();
          const bRightMid = (rightPupil.y + frame.rightLens.bottom)/2;
          a.strokeText(`B: ${measurements.B_right_mm}mm`, rightPupil.x+45, bRightMid);
          a.fillText(`B: ${measurements.B_right_mm}mm`, rightPupil.x+45, bRightMid);

          a.beginPath(); a.moveTo(leftPupil.x-35, leftPupil.y); a.lineTo(leftPupil.x-35, frame.leftLens.bottom); a.stroke();
          const bLeftMid = (leftPupil.y + frame.leftLens.bottom)/2;
          a.strokeText(`B: ${measurements.B_left_mm}mm`, leftPupil.x-100, bLeftMid);
          a.fillText(`B: ${measurements.B_left_mm}mm`, leftPupil.x-100, bLeftMid);
        }

        return annotCanvas.toDataURL();
      };

      const processImage = async () => {
        if (!image) return;
        setProcessing(true); setError(null); setProcessingStep("Iniciando an√°lisis...");

        try {
          const img = new Image();
          img.src = image;
          await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; });

          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          canvas.width = img.width; canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          // 1) Tarjeta
          await new Promise(r=>setTimeout(r,300));
          const card = detectCardReal(ctx, canvas.width, canvas.height);
          if (!card.found) throw new Error("No se pudo detectar la tarjeta CR80. Aseg√∫rese de que est√© visible, completa y bien iluminada en la foto.");

          // 2) Escala (usar lado M√ÅS LARGO real)
          const pxPerMm = card.longSidePx / CR80_WIDTH;

          // 3) Face landmarks
          await new Promise(r=>setTimeout(r,500));
          const landmarks = await detectFaceReal(img, canvas.width, canvas.height);

          // 4) Validar que tarjeta est√© cerca del rostro (evitar falsos positivos lejos)
          const fx = (landmarks.leftPupil.x + landmarks.rightPupil.x)/2;
          const fy = (landmarks.leftPupil.y + landmarks.rightPupil.y)/2;
          const eyeSpan = Math.abs(landmarks.rightPupil.x - landmarks.leftPupil.x);
          const cardCx = card.corners.reduce((s,p)=>s+p.x,0)/4;
          const cardCy = card.corners.reduce((s,p)=>s+p.y,0)/4;
          const tooFar = Math.hypot(cardCx-fx, cardCy-fy) > 2.5 * eyeSpan;
          if (tooFar) throw new Error("Tarjeta detectada demasiado lejos del rostro. Col√≥cala a la altura de la mejilla y paralela a la c√°mara.");

          // 5) Armaz√≥n
          await new Promise(r=>setTimeout(r,400));
          const frame = detectFrameReal(ctx, landmarks, canvas.width, canvas.height);

          // 6) C√°lculos
          await new Promise(r=>setTimeout(r,300));
          const measurements = calculateMeasurements(card, landmarks, frame, pxPerMm);

          // 7) Calidad
          const quality = {
            confidence_DI: landmarks.confidence,
            confidence_A: frame.found ? frame.confidence : 0,
            confidence_B: frame.found ? frame.confidence * 0.95 : 0,
            flags: [],
            notes: ""
          };
          if (measurements.DI_mm < 50 || measurements.DI_mm > 75) {
            quality.flags.push("unusual_ipd_value");
            quality.notes += "IPD fuera del rango t√≠pico (50-75mm). Verifique la coplanaridad tarjeta/rostro. ";
          }
          if (!frame.found) {
            quality.flags.push("no_frame_detected");
            quality.notes += "No se detect√≥ armaz√≥n. Use una foto con anteojos para A/B. ";
          }
          if (landmarks.method === "Estimaci√≥n") {
            quality.flags.push("fallback_detection_used");
            quality.notes += "Se us√≥ m√©todo de estimaci√≥n. Asegure buena iluminaci√≥n y rostro visible. ";
          }
          if (!quality.notes) {
            quality.notes = `Medici√≥n exitosa usando ${landmarks.method}. IPD detectado: ${measurements.DI_mm}mm. `;
            if (frame.found) quality.notes += "Todas las mediciones calculadas con buena confianza.";
          }

          const out = {
            measurements,
            calibration: {
              px_per_mm: pxPerMm,
              card_detected: card.found,
              card_skew_deg: card.angle || 0,
              perspective_corrected: true
            },
            quality,
            detectionMethod: landmarks.method
          };
          setResults(out);

          // 8) Imagen anotada
          await new Promise(r=>setTimeout(r,400));
          const annotated = createAnnotatedImage(ctx, img, card, landmarks, frame, measurements, pxPerMm);
          setAnnotatedImage(annotated);
          setProcessingStep("¬°Completado!");
        } catch (err) {
          console.error(err);
          setError(err.message || String(err));
          setProcessingStep("");
        } finally {
          setTimeout(()=>{ setProcessing(false); setProcessingStep(""); }, 500);
        }
      };

      const downloadResults = () => {
        if (!results) return;
        const dataStr = JSON.stringify(results, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement("a");
        link.href = url; link.download = `optical-measurements-${Date.now()}.json`; link.click();
        URL.revokeObjectURL(url);
      };

      const downloadAnnotatedImage = () => {
        if (!annotatedImage) return;
        const link = document.createElement("a");
        link.href = annotatedImage;
        link.download = `annotated-measurement-${Date.now()}.png`;
        link.click();
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 p-4">
          <div className="max-w-7xl mx-auto">
            {/* Header */}
            <div className="bg-white rounded-2xl shadow-xl p-6 mb-6 border-t-4 border-indigo-600">
              <div className="flex items-center justify-between flex-wrap gap-4">
                <div className="flex items-center gap-3">
                  <div className="bg-indigo-100 p-3 rounded-xl">
                    <Eye className="w-8 h-8 text-indigo-600" />
                  </div>
                  <div>
                    <h1 className="text-3xl font-bold text-gray-800">Medidor √ìptico Facial</h1>
                    <p className="text-gray-600 mt-1">An√°lisis profesional de IPD para calibraci√≥n de anteojos</p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {loadingModels ? (
                    <div className="flex items-center gap-2 text-sm text-yellow-600 bg-yellow-50 px-4 py-2 rounded-lg">
                      <Loader className="w-4 h-4" />
                      <span>Cargando modelos‚Ä¶</span>
                    </div>
                  ) : faceMeshReady ? (
                    <div className="flex items-center gap-2 text-sm text-green-600 bg-green-50 px-4 py-2 rounded-lg">
                      <CheckCircle className="w-4 h-4" />
                      <span>MediaPipe Activo</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-2 text-sm text-blue-600 bg-blue-50 px-4 py-2 rounded-lg">
                      <Zap className="w-4 h-4" />
                      <span>Modo Estimaci√≥n</span>
                    </div>
                  )}
                </div>
              </div>
            </div>

            {/* Instructions */}
            <div className="bg-gradient-to-r from-blue-600 to-indigo-600 rounded-2xl shadow-xl p-6 mb-6 text-white">
              <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                <Info className="w-5 h-5" />
                Requisitos de la Fotograf√≠a para Medici√≥n Precisa
              </h2>
              <div className="grid md:grid-cols-2 gap-3">
                <div className="flex items-start gap-2"><CheckCircle className="w-5 h-5 mt-0.5"/><span className="text-sm">Rostro frontal, mirada directa, ojos bien abiertos</span></div>
                <div className="flex items-start gap-2"><CheckCircle className="w-5 h-5 mt-0.5"/><span className="text-sm">Tarjeta CR80 visible y completa (tarjeta de cr√©dito est√°ndar)</span></div>
                <div className="flex items-start gap-2"><CheckCircle className="w-5 h-5 mt-0.5"/><span className="text-sm">Tarjeta en el mismo plano del rostro (altura de ojos)</span></div>
                <div className="flex items-start gap-2"><CheckCircle className="w-5 h-5 mt-0.5"/><span className="text-sm">Buena iluminaci√≥n uniforme, sin sombras fuertes</span></div>
              </div>
              <div className="mt-4 bg-white/20 backdrop-blur-lg rounded-lg p-3 text-sm">
                <p><strong>Nota:</strong> La tarjeta CR80 (85.60 √ó 53.98 mm) se usa como referencia para calibrar las mediciones.</p>
              </div>
            </div>

            <div className="grid lg:grid-cols-2 gap-6">
              {/* Left */}
              <div className="space-y-6">
                <div className="bg-white rounded-2xl shadow-xl p-6">
                  <h2 className="text-xl font-semibold text-gray-800 mb-4">Captura de Imagen</h2>
                  <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" className="hidden" />
                  <div className="grid grid-cols-2 gap-3">
                    <button onClick={()=>fileInputRef.current?.click()} disabled={loadingModels}
                      className="bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-all hover:scale-105">
                      <Upload className="w-5 h-5" /> Subir Foto
                    </button>
                    <button onClick={cameraActive ? capturePhoto : startCamera} disabled={loadingModels}
                      className="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-all hover:scale-105">
                      <Camera className="w-5 h-5" /> {cameraActive ? "Capturar" : "C√°mara"}
                    </button>
                  </div>

                  {cameraActive && (
                    <div className="mt-4">
                      <video ref={videoRef} className="w-full rounded-xl shadow-lg" autoPlay playsInline muted></video>
                      <button onClick={stopCamera} className="w-full mt-2 bg-red-500 hover:bg-red-600 text-white py-2 rounded-lg text-sm font-medium">Cerrar C√°mara</button>
                    </div>
                  )}

                  {image && !cameraActive && (
                    <button onClick={processImage} disabled={processing || loadingModels}
                      className="w-full mt-4 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-xl flex items-center justify-center gap-2 transition-all hover:scale-105">
                      <Ruler className="w-5 h-5" /> {processing ? "Procesando..." : "Analizar IPD"}
                    </button>
                  )}

                  {processing && (
                    <div className="mt-4 bg-indigo-50 rounded-lg p-4">
                      <div className="flex items-center gap-3 mb-2">
                        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-600"></div>
                        <span className="text-indigo-700 font-medium text-sm">{processingStep}</span>
                      </div>
                      <div className="w-full bg-indigo-200 rounded-full h-2">
                        <div className="bg-indigo-600 h-2 rounded-full animate-pulse" style={{width: "70%"}}></div>
                      </div>
                    </div>
                  )}
                </div>

                {image && !cameraActive && (
                  <div className="bg-white rounded-2xl shadow-xl p-6">
                    <h3 className="text-lg font-semibold text-gray-800 mb-4">Imagen Original</h3>
                    <img src={image} alt="Original" className="w-full rounded-xl shadow-md" />
                  </div>
                )}

                {annotatedImage && (
                  <div className="bg-white rounded-2xl shadow-xl p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="text-lg font-semibold text-gray-800">Imagen Anotada</h3>
                      <button onClick={downloadAnnotatedImage}
                        className="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg flex items-center gap-2 text-sm transition-all hover:scale-105">
                        <Download className="w-4 h-4" /> Descargar
                      </button>
                    </div>
                    <img src={annotatedImage} alt="Annotated" className="w-full rounded-xl shadow-md" />
                  </div>
                )}
              </div>

              {/* Right */}
              <div className="space-y-6">
                {error && (
                  <div className="bg-red-50 border-l-4 border-red-500 p-4 rounded-xl shadow-lg">
                    <div className="flex items-center gap-2"><AlertCircle className="w-5 h-5 text-red-600" /><p className="text-red-800 font-semibold">Error de Procesamiento</p></div>
                    <p className="text-red-700 mt-2 text-sm">{error}</p>
                    <p className="text-red-600 mt-2 text-xs">Sugerencias: iluminaci√≥n uniforme, rostro visible, tarjeta CR80 completa y coplanar con el rostro.</p>
                  </div>
                )}

                {results && (
                  <>
                    <div className="bg-gradient-to-br from-indigo-600 to-purple-600 rounded-2xl shadow-xl p-6 text-white">
                      <div className="flex justify-between items-center mb-4">
                        <h3 className="text-xl font-semibold">Medici√≥n de IPD/DI</h3>
                        <button onClick={downloadResults}
                          className="bg-white text-indigo-600 hover:bg-indigo-50 py-2 px-4 rounded-lg flex items-center gap-2 text-sm font-medium transition-all hover:scale-105">
                          <Download className="w-4 h-4" /> JSON
                        </button>
                      </div>
                      <div className="bg-white/20 backdrop-blur-lg rounded-xl p-6 mb-4">
                        <div className="text-center">
                          <p className="text-sm opacity-90 mb-2">Distancia Interpupilar</p>
                          <p className="text-5xl font-bold mb-1">{results.measurements.DI_mm}</p>
                          <p className="text-2xl font-semibold opacity-90">mil√≠metros</p>
                          <div className="mt-3 pt-3 border-t border-white/30">
                            <p className="text-xs opacity-75">M√©todo de detecci√≥n</p>
                            <p className="text-sm font-semibold mt-1">{results.detectionMethod}</p>
                          </div>
                        </div>
                      </div>
                      {results.measurements.A_right_mm !== null && (
                        <div className="grid grid-cols-2 gap-3">
                          <div className="bg-white/20 backdrop-blur-lg rounded-xl p-3">
                            <p className="text-xs opacity-75 mb-1">A Derecha (PD)</p>
                            <p className="text-xl font-bold">{results.measurements.A_right_mm} mm</p>
                          </div>
                          <div className="bg-white/20 backdrop-blur-lg rounded-xl p-3">
                            <p className="text-xs opacity-75 mb-1">A Izquierda (PD)</p>
                            <p className="text-xl font-bold">{results.measurements.A_left_mm} mm</p>
                          </div>
                          <div className="bg-white/20 backdrop-blur-lg rounded-xl p-3">
                            <p className="text-xs opacity-75 mb-1">B Derecha</p>
                            <p className="text-xl font-bold">{results.measurements.B_right_mm} mm</p>
                          </div>
                          <div className="bg-white/20 backdrop-blur-lg rounded-xl p-3">
                            <p className="text-xs opacity-75 mb-1">B Izquierda</p>
                            <p className="text-xl font-bold">{results.measurements.B_left_mm} mm</p>
                          </div>
                        </div>
                      )}
                    </div>

                    <div className="bg-blue-50 border-l-4 border-blue-500 rounded-xl p-4">
                      <div className="flex items-start gap-3"><Info className="w-5 h-5 text-blue-600 mt-0.5"/><div className="text-sm text-blue-900"><p className="font-semibold mb-1">¬øQu√© es el IPD/DI?</p><p className="text-blue-800">La Distancia Interpupilar (IPD o DI) es la distancia entre los centros de las pupilas. Fundamental para la alineaci√≥n correcta de lentes.</p></div></div>
                    </div>

                    {results.measurements.extras && results.measurements.extras.bridge_mm !== null && (
                      <div className="bg-white rounded-2xl shadow-xl p-6">
                        <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2"><Ruler className="w-5 h-5 text-indigo-600" /> Mediciones del Armaz√≥n</h3>
                        <div className="space-y-3">
                          <div className="flex justify-between items-center p-3 bg-gradient-to-r from-indigo-50 to-purple-50 rounded-lg border border-indigo-200">
                            <span className="text-gray-700 font-medium">Puente</span>
                            <span className="text-lg font-bold text-indigo-600">{results.measurements.extras.bridge_mm} mm</span>
                          </div>
                          <div className="grid grid-cols-2 gap-3">
                            <div className="p-3 bg-blue-50 rounded-lg border border-blue-200"><p className="text-xs text-gray-600 mb-1">Ancho Lente Der.</p><p className="text-base font-bold text-blue-700">{results.measurements.extras.lens_right_width_mm} mm</p></div>
                            <div className="p-3 bg-blue-50 rounded-lg border border-blue-200"><p className="text-xs text-gray-600 mb-1">Ancho Lente Izq.</p><p className="text-base font-bold text-blue-700">{results.measurements.extras.lens_left_width_mm} mm</p></div>
                            <div className="p-3 bg-purple-50 rounded-lg border border-purple-200"><p className="text-xs text-gray-600 mb-1">Alto Lente Der.</p><p className="text-base font-bold text-purple-700">{results.measurements.extras.lens_right_height_mm} mm</p></div>
                            <div className="p-3 bg-purple-50 rounded-lg border border-purple-200"><p className="text-xs text-gray-600 mb-1">Alto Lente Izq.</p><p className="text-base font-bold text-purple-700">{results.measurements.extras.lens_left_height_mm} mm</p></div>
                          </div>
                        </div>
                      </div>
                    )}

                    <div className="bg-white rounded-2xl shadow-xl p-6">
                      <h3 className="text-lg font-semibold text-gray-800 mb-4">Informaci√≥n de Calibraci√≥n</h3>
                      <div className="space-y-3">
                        <div className="flex justify-between items-center p-3 bg-gradient-to-r from-green-50 to-emerald-50 rounded-lg border border-green-200">
                          <span className="text-gray-700 font-medium">Tarjeta Detectada</span>
                          <div className="flex items-center gap-2"><CheckCircle className="w-5 h-5 text-green-600"/><span className="font-bold text-green-700">S√≠</span></div>
                        </div>
                        <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg"><span className="text-gray-600 text-sm">Escala (px/mm)</span><span className="font-mono font-semibold text-gray-800">{results.calibration.px_per_mm.toFixed(3)}</span></div>
                        <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg"><span className="text-gray-600 text-sm">Resoluci√≥n Efectiva</span><span className="font-semibold text-gray-800">{(1/results.calibration.px_per_mm).toFixed(2)} mm/px</span></div>
                        <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg"><span className="text-gray-600 text-sm">Inclinaci√≥n Tarjeta</span><span className="font-bold text-green-600">{Number(results.calibration.card_skew_deg||0).toFixed(1)}¬∞</span></div>
                      </div>
                    </div>

                    <div className="bg-white rounded-2xl shadow-xl p-6">
                      <h3 className="text-lg font-semibold text-gray-800 mb-4">Calidad de Medici√≥n</h3>
                      <div className="space-y-4">
                        <div>
                          <div className="flex justify-between mb-2"><span className="text-sm font-medium text-gray-700">Confianza IPD/DI</span><span className="text-sm font-bold text-indigo-600">{(results.quality.confidence_DI*100).toFixed(0)}%</span></div>
                          <div className="w-full bg-gray-200 rounded-full h-3 overflow-hidden"><div className="bg-gradient-to-r from-green-500 to-emerald-600 h-3 rounded-full transition-all duration-500" style={{width: `${results.quality.confidence_DI*100}%`}}></div></div>
                        </div>
                        {results.measurements.A_right_mm !== null && (
                          <>
                            <div>
                              <div className="flex justify-between mb-2"><span className="text-sm font-medium text-gray-700">Confianza A (Naso-Pupilar)</span><span className="text-sm font-bold text-blue-600">{(results.quality.confidence_A*100).toFixed(0)}%</span></div>
                              <div className="w-full bg-gray-200 rounded-full h-3 overflow-hidden"><div className="bg-gradient-to-r from-blue-500 to-indigo-600 h-3 rounded-full transition-all duration-500" style={{width: `${results.quality.confidence_A*100}%`}}></div></div>
                            </div>
                            <div>
                              <div className="flex justify-between mb-2"><span className="text-sm font-medium text-gray-700">Confianza B (Altura)</span><span className="text-sm font-bold text-yellow-600">{(results.quality.confidence_B*100).toFixed(0)}%</span></div>
                              <div className="w-full bg-gray-200 rounded-full h-3 overflow-hidden"><div className="bg-gradient-to-r from-yellow-500 to-orange-600 h-3 rounded-full transition-all duration-500" style={{width: `${results.quality.confidence_B*100}%`}}></div></div>
                            </div>
                          </>
                        )}
                        {results.quality.flags.length > 0 && (
                          <div className="mt-4 p-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-lg">
                            <div className="flex items-center gap-2 mb-2"><AlertCircle className="w-5 h-5 text-yellow-600"/><p className="text-sm font-semibold text-yellow-800">Advertencias de Calidad</p></div>
                            <ul className="text-sm text-yellow-700 space-y-1 ml-7 list-disc">
                              {results.quality.flags.map((f,i)=> <li key={i}>{f}</li>)}
                            </ul>
                          </div>
                        )}
                        {results.quality.notes && (
                          <div className="mt-4 p-4 bg-blue-50 border-l-4 border-blue-400 rounded-lg">
                            <p className="text-sm text-blue-800 leading-relaxed">{results.quality.notes}</p>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="bg-gradient-to-br from-purple-100 to-pink-100 rounded-2xl shadow-xl p-6 border-2 border-purple-200">
                      <h3 className="text-lg font-semibold text-purple-900 mb-3 flex items-center gap-2">
                        <Info className="w-5 h-5" /> Medidas de Referencia (PDF)
                      </h3>
                      <p className="text-sm text-purple-700 mb-4">Valores del documento proporcionado para comparaci√≥n:</p>
                      <div className="grid grid-cols-4 gap-2">
                        {REFERENCE_MEASUREMENTS.map((ref, idx) => (
                          <div key={idx} className="bg-white p-3 rounded-lg shadow-sm text-center border border-purple-200">
                            <p className="text-xs text-gray-500 mb-1">{ref.label}</p>
                            <p className="text-sm font-bold text-purple-700">{ref.value} mm</p>
                          </div>
                        ))}
                      </div>
                    </div>
                  </>
                )}

                {/* Ayuda inicial */}
                {!results && !error && !image && !loadingModels && (
                  <div className="bg-white rounded-2xl shadow-xl p-8 text-center">
                    <div className="bg-indigo-100 w-20 h-20 rounded-full flex items-center justify-center mx-auto mb-4"><Eye className="w-10 h-10 text-indigo-600" /></div>
                    <h3 className="text-xl font-semibold text-gray-800 mb-2">Comience con una Fotograf√≠a</h3>
                    <p className="text-gray-600 mb-6">Suba una imagen o use la c√°mara para medir el IPD (Distancia Interpupilar)</p>
                    <div className="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-xl p-4 text-left">
                      <p className="text-sm font-semibold text-gray-700 mb-2">Proceso de medici√≥n:</p>
                      <ol className="text-sm text-gray-600 space-y-1 ml-4 list-decimal">
                        <li>Detecci√≥n de tarjeta CR80 (rotada) con OpenCV</li>
                        <li>Calibraci√≥n px/mm por lado largo (85.60mm)</li>
                        <li>Detecci√≥n facial con MediaPipe (468 landmarks)</li>
                        <li>Centros pupilares a partir de iris</li>
                        <li>IPD = distancia pupilar / escala</li>
                        <li>Medidas A y B si hay armaz√≥n</li>
                      </ol>
                    </div>
                  </div>
                )}
              </div>
            </div>

            <canvas ref={canvasRef} className="hidden-canvas"></canvas>

            <div className="mt-8 text-center text-sm text-gray-600 pb-4">
              <p className="font-semibold">Medidor √ìptico Facial v2.0 - Medici√≥n Real de IPD</p>
              <p className="mt-1">React + MediaPipe Face Mesh + OpenCV.js</p>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<OpticalMeasurementApp />);
  </script>
</body>
</html>