<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Medidor Óptico Facial — CR80 + OpenCV/MediaPipe</title>

<!-- Tailwind -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- React + Babel UMD -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- OpenCV opcional (para score extra) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<style>
  html,body{background:#eef2ff}
  /* Contenedor fijo alto (no scrollea la página cuando se abre la cam) */
  .viewer{position:relative;border-radius:12px;overflow:hidden;background:#000;max-height:62vh}
  video.cam{
    display:block;width:100%;height:auto;max-height:62vh;object-fit:cover;
    transform:scaleX(-1); /* espejo para selfie */
    background:#000;
  }
  canvas.overlay{position:absolute;inset:0;pointer-events:none;z-index:20}
  .capture-fab{
    position:absolute;left:50%;bottom:12px;transform:translateX(-50%);
    width:56px;height:56px;border-radius:9999px;display:flex;align-items:center;justify-content:center;
    background:rgba(37,99,235,.96);color:#fff;font-size:22px;border:3px solid #fff;z-index:30;
    box-shadow:0 10px 28px rgba(37,99,235,.35);
  }
  .tag{font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {useRef,useState,useEffect,useMemo} = React;

const CR80_W=85.60, CR80_H=53.98, CR80_AR=CR80_W/CR80_H;

function App(){
  const [state,setState]=useState('idle');
  const [err,setErr]=useState('');
  const [ocvReady,setOcvReady]=useState(false);

  const vidRef=useRef(null);
  const overlayRef=useRef(null);
  const viewerRef=useRef(null);
  const streamRef=useRef(null);
  const workRef=useRef(document.createElement('canvas'));

  const [cameraOn,setCameraOn]=useState(false);
  const [image,setImage]=useState(null);
  const [annotated,setAnnotated]=useState(null);

  const [useGuide,setUseGuide]=useState(true);
  const [scorePct,setScorePct]=useState(0);
  const [guidePx,setGuidePx]=useState(120);
  const [fineAdj,setFineAdj]=useState(0);
  const pxPerMm=useMemo(()=> (guidePx/CR80_W)*(1+fineAdj/100),[guidePx,fineAdj]);

  // MediaPipe
  const [faceMesh,setFaceMesh]=useState(null);
  const lastFaceCenter=useRef(null);

  useEffect(()=>{
    const init=()=>{
      try{
        const fm=new window.FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
        fm.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
        setFaceMesh(fm);
      }catch(_){}
    };
    if(typeof window.FaceMesh==='undefined'){
      const s=document.createElement('script'); s.async=true;
      s.src='https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
      s.onload=()=>{
        const u=document.createElement('script'); u.async=true;
        u.src='https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';
        u.onload=init; document.body.appendChild(u);
      };
      document.body.appendChild(s);
    }else init();
  },[]);

  useEffect(()=>{
    const t=setInterval(()=>{ if(window.cv && window.cv.Mat){ setOcvReady(true); clearInterval(t);} },300);
    return()=>clearInterval(t);
  },[]);

  /* === Cámara === */
  const startCam=()=>{
    setErr('');
    const go=async(retry=0)=>{
      const v=vidRef.current;
      if(!v){ if(retry<6) return requestAnimationFrame(()=>go(retry+1)); setErr('videoRef no disponible'); setState('error'); return; }
      try{
        v.setAttribute('playsinline',''); v.setAttribute('autoplay',''); v.muted=true; v.playsInline=true;
        const stream=await navigator.mediaDevices.getUserMedia({
          video:{facingMode:{ideal:'user'},width:{ideal:1280},height:{ideal:720}}, audio:false
        });
        streamRef.current=stream; v.srcObject=stream; await v.play();
        setCameraOn(true); setState('ready');
      }catch(e){ setErr('No se pudo acceder a la cámara: '+(e.message||e)); setState('error'); }
    };
    go();
  };

  const stopCam=()=>{
    const v=vidRef.current; if(v){v.pause(); v.srcObject=null;}
    if(streamRef.current){ streamRef.current.getTracks().forEach(t=>t.stop()); streamRef.current=null; }
    setCameraOn(false);
  };

  /* === Utiles === */
  const edgeScore=(imgData,w,h)=>{
    const t=3; let e=0, tot=0;
    for(let y=0;y<h;y++){
      const b=(y<t)||(y>=h-t);
      for(let x=0;x<w;x++){
        if(!b && (x>=t && x<w-t)) continue;
        const i=(y*w+x)*4;
        const lum=0.299*imgData.data[i]+0.587*imgData.data[i+1]+0.114*imgData.data[i+2];
        if(lum<75 || lum>205) e++; tot++;
      }
    }
    return tot? e/tot : 0;
  };

  /* === Overlay: siempre visible y del tamaño exacto en pantalla === */
  useEffect(()=>{
    if(!cameraOn) return;
    const v=vidRef.current, ov=overlayRef.current, viewer=viewerRef.current;
    if(!v||!ov||!viewer) return;

    const ctx=ov.getContext('2d');
    const work=workRef.current, wctx=work.getContext('2d',{willReadFrequently:true});

    const syncCanvasToCSS=()=>{
      // usa tamaño visible (CSS) para evitar overlay 0x0 en iOS
      const rect = v.getBoundingClientRect();
      ov.style.width = rect.width+'px';
      ov.style.height= rect.height+'px';
      ov.width  = Math.max(1, Math.round(rect.width  * devicePixelRatio));
      ov.height = Math.max(1, Math.round(rect.height * devicePixelRatio));
    };
    syncCanvasToCSS();
    const ro=new ResizeObserver(syncCanvasToCSS);
    ro.observe(viewer); ro.observe(v);

    let raf=0;
    const loop=()=>{
      // dimensiones visibles
      const rect=v.getBoundingClientRect();
      const cssW=rect.width, cssH=rect.height;
      if(cssW<=0||cssH<=0){ raf=requestAnimationFrame(loop); return; }

      // limpiar
      ctx.clearRect(0,0,ov.width,ov.height);

      // posición guía bajo la nariz (si hay landmarks); conversion a px canvas (considerando DPR)
      const dpr=devicePixelRatio||1;
      let gyBase = (cssH*0.58)*dpr;
      if(lastFaceCenter.current){
        const y=lastFaceCenter.current.y*(ov.height/(v.videoHeight||cssH)); // map a canvas px
        gyBase = Math.min(ov.height-20, Math.max(20, y + (cssH*0.12)*dpr));
      }

      const gw = (guidePx * ov.width) / (v.videoWidth || ov.width); // mantener escala si videoWidth=0
      const gh = Math.round(gw/CR80_AR);
      const gx = Math.round((ov.width - gw)/2);
      const gy = Math.round(gyBase - gh/2);

      // máscara y rectángulo
      if(useGuide){
        ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,ov.width,ov.height);
        ctx.clearRect(gx,gy,gw,gh);
      }

      // ROI real (tomado del frame, corrigiendo espejo)
      const vw=v.videoWidth||Math.round(cssW), vh=v.videoHeight||Math.round(cssH);
      work.width=vw; work.height=vh; wctx.drawImage(v,0,0,vw,vh);
      const scaleX = vw/ov.width, scaleY=vh/ov.height;
      const roiX = (vw - Math.round(gx*scaleX) - Math.round(gw*scaleX)); // espejo
      const roiY = Math.round(gy*scaleY);
      const roiW = Math.round(gw*scaleX), roiH = Math.round(gh*scaleY);
      const roi = wctx.getImageData(Math.max(0,roiX), Math.max(0,roiY), Math.max(1,roiW), Math.max(1,roiH));

      // score combinado (edges + opcional OpenCV)
      let combined=edgeScore(roi,roiW,roiH);
      if(ocvReady){
        try{
          const cv=window.cv;
          const src=cv.matFromImageData(roi);
          const gray=new cv.Mat(), bl=new cv.Mat(), ed=new cv.Mat();
          cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,bl,new cv.Size(5,5),0);
          let sum=0; const d=bl.data; for(let i=0;i<d.length;i++) sum+=d[i];
          const mean=sum/d.length; const lo=Math.max(0,.66*mean), hi=Math.min(255,1.33*mean);
          cv.Canny(bl,ed,lo,hi);
          const contours=new cv.MatVector(), hier=new cv.Mat();
          cv.findContours(ed,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
          let best=0;
          for(let i=0;i<contours.size();i++){
            const cnt=contours.get(i); const area=cv.contourArea(cnt);
            if(area<(roiW*roiH)*0.06){ cnt.delete(); continue; }
            const rect=cv.minAreaRect(cnt);
            const L=Math.max(rect.size.width,rect.size.height), S=Math.min(rect.size.width,rect.size.height);
            const ar=L/S; const asp=Math.max(0,1-Math.min(Math.abs(ar-CR80_AR)/0.30,1));
            const cont=Math.max(0,Math.min(1,(area/(roiW*roiH))*2.2));
            best=Math.max(best, asp*0.7+cont*0.3); cnt.delete();
          }
          gray.delete(); bl.delete(); ed.delete(); contours.delete(); hier.delete(); src.delete();
          combined=Math.max(combined,best);
        }catch(_){}
      }
      setScorePct(combined);

      // marco visible
      if(useGuide){
        ctx.lineWidth=3*dpr; ctx.strokeStyle=combined>=0.75? '#22c55e':'#a78bfa'; ctx.strokeRect(gx,gy,gw,gh);
        ctx.font=`700 ${14*dpr}px system-ui,-apple-system`; ctx.fillStyle='#fff'; ctx.strokeStyle='#000'; ctx.lineWidth=4*dpr;
        const label=`Guía CR80 — score ${Math.round(combined*100)}%`;
        ctx.strokeText(label,12*dpr,Math.max(22*dpr, gy-8*dpr)); ctx.fillText(label,12*dpr,Math.max(22*dpr, gy-8*dpr));
      }
      raf=requestAnimationFrame(loop);
    };
    raf=requestAnimationFrame(loop);
    return()=>{ cancelAnimationFrame(raf); ro.disconnect(); };
  },[cameraOn,useGuide,guidePx,ocvReady]);

  /* Capturar y procesar */
  const capture=async()=>{
    const v=vidRef.current; if(!v||!(v.videoWidth||v.clientWidth)){ setErr('La cámara no está lista.'); return; }
    const c=document.createElement('canvas');
    const w=v.videoWidth||v.clientWidth, h=v.videoHeight||v.clientHeight;
    c.width=w; c.height=h; c.getContext('2d').drawImage(v,0,0,w,h);
    const url=c.toDataURL('image/jpeg',0.92);
    setImage(url); setAnnotated(null);
    process(url);
  };

  const process=async(srcUrl)=>{
    const src = srcUrl || image; if(!src){ setErr('No hay imagen.'); return; }
    try{
      const img=await new Promise((res,rej)=>{ const m=new Image(); m.src=src; m.onload=()=>res(m); m.onerror=rej; });

      const getLm=()=> new Promise((resolve)=>{
        if(faceMesh){
          const c=document.createElement('canvas'); c.width=img.width; c.height=img.height;
          c.getContext('2d').drawImage(img,0,0);
          faceMesh.onResults(r=>{
            if(r.multiFaceLandmarks && r.multiFaceLandmarks[0]){
              const L=r.multiFaceLandmarks[0];
              const mean=(idxs)=>idxs.reduce((S,i)=>({x:S.x+L[i].x*img.width,y:S.y+L[i].y*img.height}),{x:0,y:0});
              const Rm=mean([468,469,470,471,472]), Lm=mean([473,474,475,476,477]);
              const R={x:Rm.x/5,y:Rm.y/5}, Lp={x:Lm.x/5,y:Lm.y/5};
              lastFaceCenter.current={x:(R.x+Lp.x)/2,y:(R.y+Lp.y)/2};
              resolve({R, L: Lp, method:'MediaPipe'});
            }else{
              const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
              resolve({R:{x:cx+d/2,y:cy}, L:{x:cx-d/2,y:cy}, method:'Estimación'});
            }
          });
          faceMesh.send({image:c});
        }else{
          const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
          resolve({R:{x:cx+d/2,y:cy}, L:{x:cx-d/2,y:cy}, method:'Estimación'});
        }
      });

      const lm=await getLm();
      const dx=lm.R.x-lm.L.x, dy=lm.R.y-lm.L.y;
      const ipd = Math.hypot(dx,dy)/pxPerMm;
      const ipd10 = Math.round(ipd*10)/10;

      // anotada — línea 3px y puntos radio 6px
      const out=document.createElement('canvas'); out.width=img.width; out.height=img.height;
      const a=out.getContext('2d'); a.drawImage(img,0,0);
      a.fillStyle='#ef4444';
      a.beginPath(); a.arc(lm.L.x,lm.L.y,6,0,Math.PI*2); a.fill();
      a.beginPath(); a.arc(lm.R.x,lm.R.y,6,0,Math.PI*2); a.fill();
      a.strokeStyle='#ef4444'; a.lineWidth=3; a.beginPath(); a.moveTo(lm.L.x,lm.L.y); a.lineTo(lm.R.x,lm.R.y); a.stroke();
      a.font='700 22px system-ui,-apple-system'; a.fillStyle='#fff'; a.strokeStyle='#000'; a.lineWidth=5;
      const mx=(lm.L.x+lm.R.x)/2, my=(lm.L.y+lm.R.y)/2-18;
      a.strokeText(`IPD: ${ipd10} mm`,mx-80,my); a.fillText(`IPD: ${ipd10} mm`,mx-80,my);
      setAnnotated(out.toDataURL('image/png'));
    }catch(e){ setErr('No se pudo procesar: '+(e.message||e)); }
  };

  return (
    <div className="min-h-screen p-4">
      <div className="max-w-3xl mx-auto space-y-4">
        <header className="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-500">
          <div className="flex items-center justify-between gap-3">
            <div>
              <h1 className="text-3xl font-bold leading-tight">Medidor Óptico Facial</h1>
              <p className="text-slate-600">Guía CR80 + OpenCV/MediaPipe</p>
            </div>
            <div className="flex gap-2 text-xs">
              <span className="px-2 py-1 rounded bg-slate-100">secure: <b className="tag">{location.protocol==='https:'?'true':'false'}</b></span>
              <span className="px-2 py-1 rounded bg-slate-100">opencv: <b className="tag">{ocvReady?'ready':'loading'}</b></span>
              <span className="px-2 py-1 rounded bg-slate-100">estado: <b className="tag">{state}</b></span>
            </div>
          </div>
        </header>

        <section className="bg-white rounded-2xl shadow p-5">
          <h2 className="text-xl font-semibold mb-3">Captura de Imagen</h2>
          <div className="grid grid-cols-3 gap-3 mb-3">
            <label className="flex items-center justify-center gap-2 bg-slate-800 text-white rounded-xl py-3 cursor-pointer">
              🖼️ <span>Subir Foto</span>
              <input type="file" accept="image/*" className="hidden"
                     onChange={e=>{
                       const f=e.target.files?.[0]; if(!f) return;
                       const rd=new FileReader(); rd.onload=ev=>{ setImage(ev.target.result); setAnnotated(null); process(ev.target.result); };
                       rd.readAsDataURL(f);
                     }}/>
            </label>
            <button onClick={startCam} className="bg-violet-600 hover:bg-violet-700 text-white rounded-xl py-3">📷 Cámara</button>
            <button onClick={stopCam} className="bg-rose-600 hover:bg-rose-700 text-white rounded-xl py-3">🔴 Cerrar</button>
          </div>

          {err && <div className="bg-red-50 text-red-800 border border-red-200 rounded-xl p-3 mb-3">{err}</div>}

          <div ref={viewerRef} className="viewer">
            <video ref={vidRef} className="cam" autoplay playsinline muted></video>
            <canvas ref={overlayRef} className="overlay"></canvas>
            {cameraOn && <button className="capture-fab" onClick={capture} aria-label="Capturar">📸</button>}
          </div>

          <div className="mt-3 flex flex-wrap items-center gap-3">
            <label className="inline-flex items-center gap-2">
              <input type="checkbox" className="scale-110" checked={useGuide} onChange={e=>setUseGuide(e.target.checked)}/>
              <span>Usar Guía CR80</span>
            </label>
            <div className="ml-auto text-sm text-slate-600">
              score: <b className="tag">{Math.round(scorePct*100)}%</b>
            </div>
          </div>

          <div className="mt-4">
            <div className="text-sm text-slate-700 mb-1">Ajuste fino escala (±10%) · actual: <b className="tag">{fineAdj}%</b></div>
            <input type="range" min="-10" max="10" step="1" value={fineAdj} onChange={e=>setFineAdj(parseInt(e.target.value))} className="w-full"/>
            <div className="text-xs text-slate-500 mt-1">Escala efectiva: <b className="tag">{pxPerMm.toFixed(3)}</b> px/mm • Guía: <b className="tag">{guidePx}px</b> (alto {Math.round(guidePx/CR80_AR)}px)</div>
          </div>
        </section>

        {annotated && (
          <section className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Resultado</h3>
            <img src={annotated} className="w-full rounded-lg shadow" alt="resultado"/>
            <a className="inline-block mt-3 px-3 py-2 rounded bg-indigo-600 text-white" download="resultado.png" href={annotated}>Descargar PNG</a>
          </section>
        )}

        <footer className="text-center text-xs text-slate-500 py-6">© 2025 — CR80 + OpenCV + MediaPipe</footer>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>