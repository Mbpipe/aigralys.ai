<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Medidor √ìptico Facial ‚Äî Gu√≠a CR80</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  html,body{background:#eef2ff}
  .live-wrap{position:relative; width:100%; max-width:700px; margin:0 auto;}
  video#cam{
    width:100%; aspect-ratio: 3/4; background:#000; display:block;
    border-radius:1rem; object-fit:cover; transform:scaleX(-1); /* espejo frontal */
  }
  canvas#overlay{position:absolute; inset:0; pointer-events:none; border-radius:1rem;}
  /* Bot√≥n flotante centrado */
  .cap-btn{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:74px; height:74px; border-radius:9999px;
    display:flex; align-items:center; justify-content:center;
    background:#2563eb; color:#fff; border:4px solid #fff7;
    box-shadow:0 10px 25px rgba(0,0,0,.25);
  }
  .cap-btn:active{transform:translate(-50%,-50%) scale(.97)}
  .tag{font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<div class="min-h-screen p-4">
  <div class="max-w-3xl mx-auto space-y-4">
    <!-- Header -->
    <div class="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-600">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-3xl font-extrabold">Medidor √ìptico Facial</h1>
          <p class="text-slate-600">Gu√≠a CR80 + OpenCV/MediaPipe (auto-proceso)</p>
        </div>
        <div class="text-xs space-x-2">
          <span id="secureTag" class="px-2 py-1 rounded bg-slate-100">secure: ‚Ä¶</span>
          <span id="ocvTag" class="px-2 py-1 rounded bg-slate-100">mediapipe: ‚Ä¶</span>
          <span id="stateTag" class="px-2 py-1 rounded bg-slate-100">estado: ‚Ä¶</span>
        </div>
      </div>
    </div>

    <!-- Captura -->
    <div class="bg-white rounded-2xl shadow p-5">
      <h2 class="text-xl font-semibold mb-3">Captura de Imagen</h2>

      <div class="flex gap-3">
        <label class="flex-1 inline-flex items-center justify-center gap-2 bg-slate-800 hover:bg-slate-700 text-white font-semibold py-3 rounded-xl cursor-pointer">
          üñºÔ∏è Subir Foto
          <input id="fileIn" type="file" accept="image/*" class="hidden">
        </label>
        <button id="openBtn" class="flex-1 inline-flex items-center justify-center gap-2 bg-violet-600 hover:bg-violet-700 text-white font-semibold py-3 rounded-xl">üì∑ C√°mara</button>
        <button id="closeBtn" class="flex-1 inline-flex items-center justify-center gap-2 bg-rose-600 hover:bg-rose-700 text-white font-semibold py-3 rounded-xl">üî¥ Cerrar</button>
      </div>

      <div class="mt-4 live-wrap">
        <video id="cam" playsinline autoplay muted></video>
        <canvas id="overlay"></canvas>
        <button id="capBtn" class="cap-btn text-2xl">üì∏</button>
      </div>

      <div class="mt-3 flex flex-wrap items-center gap-4">
        <label class="inline-flex items-center gap-2">
          <input id="useGuide" type="checkbox" class="scale-110" checked>
          <span>Usar Gu√≠a CR80</span>
        </label>
        <label class="inline-flex items-center gap-2">
          <input id="autoCap" type="checkbox" class="scale-110" checked>
          <span>Auto-capturar</span>
        </label>
        <div class="text-sm text-slate-600">score: <b id="scoreTag">0%</b></div>
      </div>

      <div class="mt-3">
        <label class="text-sm text-slate-700 block mb-1">Ajuste fino escala (¬±10%) ‚Ä¢ actual: <b id="finePct" class="tag">0%</b></label>
        <input id="fineSlider" type="range" min="-10" max="10" step="1" value="0" class="w-full">
        <div class="text-xs text-slate-600 mt-1">
          Escala efectiva: <b id="pxmm" class="tag">‚Äî</b> px/mm ‚Ä¢ Gu√≠a: <b id="guidePx" class="tag">‚Äî</b>px
        </div>
      </div>
    </div>

    <!-- Resultado -->
    <div id="resultBox" class="bg-white rounded-2xl shadow p-5 hidden">
      <h3 class="text-xl font-semibold mb-3">Resultado</h3>
      <div class="grid grid-cols-2 gap-3">
        <div class="p-4 rounded-lg bg-emerald-50">
          <div class="text-xs text-slate-600">IPD</div>
          <div id="ipdVal" class="text-3xl font-extrabold">‚Äî</div>
        </div>
        <div class="p-4 rounded-lg bg-indigo-50">
          <div class="text-xs text-slate-600">Escala</div>
          <div id="scaleVal" class="text-xl font-bold">‚Äî</div>
        </div>
      </div>
      <div class="mt-3">
        <img id="annot" alt="anotada" class="w-full rounded-lg shadow">
      </div>
    </div>

    <div id="errBox" class="hidden bg-red-50 text-red-800 border border-red-200 rounded-xl p-4"></div>

    <div class="text-center text-xs text-slate-500 py-4">¬© 2025 ‚Äî CR80 + OpenCV + MediaPipe</div>
  </div>
</div>

<!-- MediaPipe -->
<script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
(function(){
  const CR80_W = 85.60, CR80_H = 53.98, CR80_AR = CR80_W/CR80_H;
  const HOLD_MS = 1200;           // tiempo de sostenido para auto-captura
  const FINE_RANGE = 0.10;        // ¬±10% ajuste fino

  // UI
  const secureTag = document.getElementById('secureTag');
  const ocvTag    = document.getElementById('ocvTag');
  const stateTag  = document.getElementById('stateTag');
  const errBox    = document.getElementById('errBox');

  const fileIn = document.getElementById('fileIn');
  const openBtn= document.getElementById('openBtn');
  const closeBtn= document.getElementById('closeBtn');
  const cam   = document.getElementById('cam');
  const overlay = document.getElementById('overlay');
  const ctx   = overlay.getContext('2d', { willReadFrequently:true });

  const capBtn = document.getElementById('capBtn');

  const useGuide = document.getElementById('useGuide');
  const autoCap  = document.getElementById('autoCap');
  const scoreTag = document.getElementById('scoreTag');

  const fineSlider = document.getElementById('fineSlider');
  const finePct = document.getElementById('finePct');
  const pxmmEl = document.getElementById('pxmm');
  const guidePxEl = document.getElementById('guidePx');

  const resultBox = document.getElementById('resultBox');
  const ipdVal = document.getElementById('ipdVal');
  const scaleVal = document.getElementById('scaleVal');
  const annotImg = document.getElementById('annot');

  let stream=null, raf=0, faceMesh=null;
  let readyForAuto=false, holdStart=0;
  let lastPxPerMm = 0;

  // helpers
  const setErr = (msg)=>{ errBox.textContent = msg; errBox.classList.remove('hidden'); };
  const clearErr = ()=> errBox.classList.add('hidden');

  secureTag.textContent = 'secure: ' + (location.protocol==='https:' ? 'true' : 'false');
  ocvTag.textContent = 'mediapipe: loading‚Ä¶';
  stateTag.textContent = 'estado: idle';

  // FaceMesh init (opcional)
  window.addEventListener('load', () => {
    try{
      faceMesh = new window.FaceMesh({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
      });
      faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
      ocvTag.textContent = 'mediapipe: ready';
    }catch(e){
      ocvTag.textContent = 'mediapipe: off';
    }
  });

  function videoReady(){
    return cam && cam.videoWidth && cam.videoHeight;
  }

  async function startCam(){
    clearErr(); stateTag.textContent='estado: opening‚Ä¶';
    try{
      cam.setAttribute('playsinline',''); cam.setAttribute('autoplay',''); cam.muted=true; cam.playsInline=true;
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:'user'}, width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      cam.srcObject = stream;
      await cam.play().catch(()=>{});
      stateTag.textContent='estado: ready';
      layout();
      loop();
    }catch(e){
      setErr('No se pudo acceder a la c√°mara: '+ (e?.message||e));
      stateTag.textContent='estado: error';
    }
  }

  function stopCam(){
    cancelAnimationFrame(raf);
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    cam.pause(); cam.srcObject=null;
    ctx.clearRect(0,0,overlay.width,overlay.height);
    stateTag.textContent='estado: closed';
  }

  function layout(){
    if(!videoReady()) return;
    overlay.width = cam.clientWidth * devicePixelRatio;
    overlay.height= cam.clientHeight * devicePixelRatio;
  }

  window.addEventListener('resize', layout);

  // --- Overlay + match scoring ---
  function loop(){
    if(!videoReady()){ raf=requestAnimationFrame(loop); return; }
    layout();
    const w=overlay.width, h=overlay.height;

    // dibujar frame video debajo del overlay para permitir ‚Äúghost‚Äù desenfoque ligero
    ctx.clearRect(0,0,w,h);

    // Gu√≠a: rect√°ngulo peque√±o centrado bajo la nariz (~60% altura)
    const guideW = Math.round(Math.min(w,h)*0.22);
    const guideH = Math.round(guideW/CR80_AR);
    const gx = Math.round((w-guideW)/2);
    const gy = Math.round(h*0.60 - guideH/2);

    // marco transl√∫cido
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,w,h);
    ctx.clearRect(gx,gy,guideW,guideH);

    // ‚Äúscore‚Äù r√°pido por bordes: cuenta transiciones alto contraste en el per√≠metro
    let edge=0, tot=0;
    try{
      const img = ctx.getImageData(gx,gy,guideW,guideH);
      const px = img.data, thick=2;
      const lumAt=(i)=> 0.299*px[i]+0.587*px[i+1]+0.114*px[i+2];

      for(let y=0;y<guideH;y++){
        for(let x=0;x<guideW;x++){
          const rim = (y<thick)||(y>=guideH-thick)||(x<thick)||(x>=guideW-thick);
          if(!rim) continue;
          const i=(y*guideW+x)*4;
          const L=lumAt(i);
          if(L<70 || L>210){ edge++; }
          tot++;
        }
      }
    }catch(_){}
    const score = tot? edge/tot : 0;
    scoreTag.textContent = Math.round(score*100)+'%';

    // contorno gu√≠a (verde si alto score)
    ctx.lineWidth = 4*devicePixelRatio;
    ctx.strokeStyle = score>=0.75 ? '#10b981' : '#a78bfa';
    ctx.strokeRect(gx,gy,guideW,guideH);

    // c√°lculo de escala base por gu√≠a (ancho real 85.60 mm)
    let pxPerMm = guideW / CR80_W;

    // ajuste fino ¬±10%
    const adj = parseInt(fineSlider.value||'0',10)/100;
    finePct.textContent = (adj>0?'+':'') + Math.round(adj*100)+'%';
    pxPerMm = pxPerMm * (1 + adj);
    lastPxPerMm = pxPerMm;
    pxmmEl.textContent = pxPerMm.toFixed(3);
    guidePxEl.textContent = guideW + 'px';

    // auto-captura (arreglada: ahora s√≠ dispara y no exige pupilas)
    if(autoCap.checked && score>=0.80){
      if(!readyForAuto){ readyForAuto=true; holdStart=performance.now(); }
      else if(performance.now()-holdStart>HOLD_MS){
        captureFrame(false); // primero sin pupilas; luego procesamos
        readyForAuto=false; holdStart=0;
      }
    }else{ readyForAuto=false; holdStart=0; }

    raf = requestAnimationFrame(loop);
  }

  // --- Captura (bot√≥n centrado SIEMPRE responde) ---
  capBtn.addEventListener('click', (e)=>{
    e.preventDefault();
    captureFrame(false);
  });

  async function captureFrame(requirePupils){
    if(!videoReady()){ setErr('La c√°mara a√∫n no est√° lista'); return; }
    clearErr();

    // Capturamos un frame n√≠tido no espejado para an√°lisis
    const cw = cam.videoWidth, ch = cam.videoHeight;
    const c = document.createElement('canvas'); c.width=cw; c.height=ch;
    const x = c.getContext('2d');
    x.save(); x.scale(-1,1); x.drawImage(cam,-cw,0,cw,ch); x.restore();
    const dataUrl = c.toDataURL('image/jpeg',0.92);

    // Landmarks con MediaPipe (si disponible)
    let pupils=null;
    if(faceMesh){
      await new Promise((resolve)=>{
        faceMesh.onResults(res=>{
          if(res.multiFaceLandmarks && res.multiFaceLandmarks[0]){
            const L=res.multiFaceLandmarks[0];
            const iris=(arr)=>({
              x: arr.reduce((s,l)=>s+l.x*cw,0)/arr.length,
              y: arr.reduce((s,l)=>s+l.y*ch,0)/arr.length
            });
            pupils = { left:iris(L.slice(473,477)), right:iris(L.slice(468,472)) };
          }
          resolve();
        });
        faceMesh.send({image:c});
      });
    }

    if(requirePupils && !pupils){
      setErr('No se detectaron pupilas. Intenta con mejor luz.');
      return;
    }

    // IPD
    let ipd_mm = null;
    if(pupils){
      const dx=pupils.right.x-pupils.left.x, dy=pupils.right.y-pupils.left.y;
      const di_px = Math.hypot(dx,dy);
      ipd_mm = di_px / (lastPxPerMm||1);
    }

    // Anotado
    const a=document.createElement('canvas'); a.width=cw; a.height=ch;
    const g=a.getContext('2d'); g.drawImage(c,0,0);
    if(pupils){
      g.lineWidth = Math.max(2, Math.round(cw/600));
      g.strokeStyle='#ff3344'; g.fillStyle='#ff3344';
      g.beginPath(); g.moveTo(pupils.left.x,pupils.left.y); g.lineTo(pupils.right.x,pupils.right.y); g.stroke();
      const r = Math.max(4, Math.round(cw/250));
      g.beginPath(); g.arc(pupils.left.x,pupils.left.y,r,0,Math.PI*2); g.fill();
      g.beginPath(); g.arc(pupils.right.x,pupils.right.y,r,0,Math.PI*2); g.fill();

      const mx=(pupils.left.x+pupils.right.x)/2, my=(pupils.left.y+pupils.right.y)/2-16;
      g.font='bold '+Math.max(16, Math.round(cw/40))+'px system-ui';
      g.lineWidth=4; g.strokeStyle='#000'; g.strokeText(`IPD: ${ipd_mm.toFixed(1)} mm`, mx-90, my);
      g.fillStyle='#fff'; g.fillText(`IPD: ${ipd_mm.toFixed(1)} mm`, mx-90, my);
    }

    // Mostrar
    resultBox.classList.remove('hidden');
    if(ipd_mm!=null) ipdVal.textContent = ipd_mm.toFixed(1)+' mm';
    else ipdVal.textContent = '‚Äî';
    scaleVal.textContent = (lastPxPerMm? lastPxPerMm.toFixed(3):'‚Äî') + ' px/mm';
    annotImg.src = a.toDataURL('image/png');
  }

  // Controles
  openBtn.addEventListener('click', startCam);
  closeBtn.addEventListener('click', stopCam);
  fileIn.addEventListener('change', (e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    const rd=new FileReader();
    rd.onload = ()=> {
      // Mostrar imagen subida en el <video> a modo de preview
      stopCam();
      cam.removeAttribute('srcObject');
      cam.srcObject=null;
      cam.src = rd.result;
      cam.style.transform='none'; // imagen no espejada
      cam.onloadeddata=()=>{ cam.play().catch(()=>{}); layout(); };
      stateTag.textContent='estado: still';
    };
    rd.readAsDataURL(f);
  });

})();
</script>
</body>
</html>