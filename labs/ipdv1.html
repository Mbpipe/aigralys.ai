<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Medidor √ìptico Facial ‚Äî CR80 + OpenCV/MediaPipe</title>

<!-- Tailwind -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- React 18 UMD + Babel -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- OpenCV (opcional para extra-score) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<style>
  html,body{background:#eef2ff}
  .viewer{position:relative;border-radius:12px;overflow:hidden;background:#000}
  video.cam{
    display:block;width:100%;height:auto;max-height:70vh;object-fit:cover;
    transform:scaleX(-1); /* espejo para usuario */
    background:#000;
  }
  canvas.overlay{position:absolute;inset:0;pointer-events:none;z-index:10}
  .capture-fab{
    position:absolute;left:50%;bottom:14px;transform:translateX(-50%);
    width:64px;height:64px;border-radius:9999px;display:flex;align-items:center;justify-content:center;
    background:rgba(37,99,235,.96);color:#fff;font-size:22px;border:3px solid #fff;z-index:20;
    box-shadow:0 10px 28px rgba(37,99,235,.35);
  }
  .tag{font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {useRef,useState,useEffect,useMemo} = React;

const CR80_W=85.60, CR80_H=53.98, CR80_AR=CR80_W/CR80_H;

function App(){
  const [state,setState]=useState('idle'); // idle|ready|error
  const [err,setErr]=useState('');
  const [ocvReady,setOcvReady]=useState(false);

  const vidRef=useRef(null);
  const overlayRef=useRef(null);
  const streamRef=useRef(null);
  const workRef=useRef(document.createElement('canvas')); // canvas offscreen

  const [cameraOn,setCameraOn]=useState(false);
  const [image,setImage]=useState(null);
  const [annotated,setAnnotated]=useState(null);

  // gu√≠a/captura
  const [useGuide,setUseGuide]=useState(true);
  const [autoCapture,setAutoCapture]=useState(false);
  const [autoProcess,setAutoProcess]=useState(true);
  const [scorePct,setScorePct]=useState(0);
  const [autoThreshold,setAutoThreshold]=useState(0.75);
  const autoBusy=useRef(false);

  // escala y ajuste fino ¬±10 %
  const [guidePx,setGuidePx]=useState(120);
  const [fineAdj,setFineAdj]=useState(0);
  const pxPerMm = useMemo(()=> (guidePx/CR80_W)*(1+fineAdj/100),[guidePx,fineAdj]);

  // MediaPipe
  const [faceMesh,setFaceMesh]=useState(null);
  const lastFaceCenter=useRef(null);

  useEffect(()=>{
    const init=()=>{
      try{
        const fm=new window.FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
        fm.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
        setFaceMesh(fm);
      }catch(_){}
    };
    if(typeof window.FaceMesh==='undefined'){
      const s=document.createElement('script'); s.async=true;
      s.src='https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
      s.onload=()=>{
        const u=document.createElement('script'); u.async=true;
        u.src='https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';
        u.onload=init; document.body.appendChild(u);
      };
      document.body.appendChild(s);
    }else init();
  },[]);

  useEffect(()=>{
    const t=setInterval(()=>{ if(window.cv && window.cv.Mat){ setOcvReady(true); clearInterval(t);} },300);
    return()=>clearInterval(t);
  },[]);

  /* c√°mara */
  const startCam=()=>{
    setErr('');
    const go=async(retry=0)=>{
      const v=vidRef.current;
      if(!v){ if(retry<6) return requestAnimationFrame(()=>go(retry+1)); setErr('videoRef no disponible'); setState('error'); return; }
      try{
        v.setAttribute('playsinline',''); v.setAttribute('autoplay',''); v.muted=true; v.playsInline=true;
        const stream=await navigator.mediaDevices.getUserMedia({
          video:{facingMode:{ideal:'user'},width:{ideal:1280},height:{ideal:720}}, audio:false
        });
        streamRef.current=stream; v.srcObject=stream; await v.play();
        setCameraOn(true); setState('ready');
      }catch(e){ setErr('No se pudo acceder a la c√°mara: '+(e.message||e)); setState('error'); }
    };
    go();
  };

  const stopCam=()=>{
    const v=vidRef.current; if(v){v.pause(); v.srcObject=null;}
    if(streamRef.current){ streamRef.current.getTracks().forEach(t=>t.stop()); streamRef.current=null; }
    setCameraOn(false);
  };

  /* edge score simple */
  const edgeScore=(imgData,w,h)=>{
    const t=3; let e=0, tot=0;
    for(let y=0;y<h;y++){
      const top=(y<t)||(y>=h-t);
      for(let x=0;x<w;x++){
        if(!top && (x>=t && x<w-t)) continue;
        const i=(y*w+x)*4;
        const lum=0.299*imgData.data[i]+0.587*imgData.data[i+1]+0.114*imgData.data[i+2];
        if(lum<75 || lum>205) e++; tot++;
      }
    }
    return tot? e/tot : 0;
  };

  /* overlay + gu√≠a (siempre que la c√°mara est√© encendida) */
  useEffect(()=>{
    if(!cameraOn) return;
    const v=vidRef.current, ov=overlayRef.current; if(!v||!ov) return;
    const ctx=ov.getContext('2d');
    const work=workRef.current, wctx=work.getContext('2d',{willReadFrequently:true});

    const loop=()=>{
      if(!v.videoWidth){ requestAnimationFrame(loop); return; }
      ov.width=v.videoWidth; ov.height=v.videoHeight;
      ctx.clearRect(0,0,ov.width,ov.height);

      // ‚Äî Posici√≥n de gu√≠a: bajo nariz si FaceMesh pudo ubicar rostro, si no fallback 0.58h
      let gyBase = Math.round(ov.height*0.58);
      if(lastFaceCenter.current){ gyBase = Math.min(ov.height-20, Math.max(20, lastFaceCenter.current.y + ov.height*0.12)); }

      const gw=guidePx, gh=Math.round(guidePx/CR80_AR);
      const gx=Math.round((ov.width-gw)/2), gy=Math.round(gyBase - gh/2);

      // m√°scara transl√∫cida
      if(useGuide){
        ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,ov.width,ov.height);
        ctx.clearRect(gx,gy,gw,gh);
      }

      // ROI real (corrigiendo espejo)
      work.width=v.videoWidth; work.height=v.videoHeight;
      wctx.drawImage(v,0,0,work.width,work.height);
      const mirroredGX = (work.width - gx - gw);
      const roi = wctx.getImageData(mirroredGX, gy, gw, gh);

      // score
      let combined = edgeScore(roi,gw,gh);
      if(ocvReady){
        try{
          const cv=window.cv;
          const src=cv.matFromImageData(roi);
          const gray=new cv.Mat(), bl=new cv.Mat(), ed=new cv.Mat();
          cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,bl,new cv.Size(5,5),0);
          let sum=0; const d=bl.data; for(let i=0;i<d.length;i++) sum+=d[i];
          const mean=sum/d.length; const lo=Math.max(0,.66*mean), hi=Math.min(255,1.33*mean);
          cv.Canny(bl,ed,lo,hi);
          const contours=new cv.MatVector(), hier=new cv.Mat();
          cv.findContours(ed,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
          let best=0;
          for(let i=0;i<contours.size();i++){
            const cnt=contours.get(i); const area=cv.contourArea(cnt);
            if(area<(gw*gh)*0.06){ cnt.delete(); continue; }
            const rect=cv.minAreaRect(cnt);
            const L=Math.max(rect.size.width,rect.size.height), S=Math.min(rect.size.width,rect.size.height);
            const ar=L/S; const asp=Math.max(0,1-Math.min(Math.abs(ar-CR80_AR)/0.30,1));
            const cont=Math.max(0,Math.min(1,(area/(gw*gh))*2.2));
            best=Math.max(best, asp*0.7+cont*0.3); cnt.delete();
          }
          gray.delete(); bl.delete(); ed.delete(); contours.delete(); hier.delete(); src.delete();
          combined=Math.max(combined,best);
        }catch(_){}
      }
      setScorePct(combined);

      // marco
      if(useGuide){
        ctx.lineWidth=4; ctx.strokeStyle=combined>=autoThreshold? '#22c55e':'#a78bfa'; ctx.strokeRect(gx,gy,gw,gh);
        ctx.font='700 20px system-ui,-apple-system'; ctx.fillStyle='#fff'; ctx.strokeStyle='#000'; ctx.lineWidth=4;
        const label=`Gu√≠a CR80 ‚Äî score ${Math.round(combined*100)}%`;
        ctx.strokeText(label,12,Math.max(26,gy-10)); ctx.fillText(label,12,Math.max(26,gy-10));
      }

      // autocaptura
      if(autoCapture && useGuide && combined>=autoThreshold && !autoBusy.current){
        autoBusy.current=true;
        capture(true);
        setTimeout(()=>{ autoBusy.current=false; },1200);
      }
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  },[cameraOn,useGuide,guidePx,autoCapture,autoThreshold,ocvReady]);

  /* captura */
  const capture=(fromAuto=false)=>{
    const v=vidRef.current; if(!v||!v.videoWidth){ setErr('La c√°mara no est√° lista.'); return; }
    const c=document.createElement('canvas'); c.width=v.videoWidth; c.height=v.videoHeight;
    const x=c.getContext('2d'); x.drawImage(v,0,0,c.width,c.height); // pixels sin espejo
    const url=c.toDataURL('image/jpeg',0.92);
    setImage(url); setAnnotated(null);
    if(autoProcess) process(url);
  };

  /* proceso con FaceMesh (iris: 5 puntos promedio) */
  const process=async(srcUrl=null)=>{
    const src = srcUrl || image; if(!src){ setErr('No hay imagen.'); return; }
    setErr('');
    try{
      const img=await new Promise((res,rej)=>{ const m=new Image(); m.src=src; m.onload=()=>res(m); m.onerror=rej; });

      const getLm=()=> new Promise((resolve)=>{
        if(faceMesh){
          const c=document.createElement('canvas'); c.width=img.width; c.height=img.height;
          c.getContext('2d').drawImage(img,0,0);
          faceMesh.onResults(r=>{
            if(r.multiFaceLandmarks && r.multiFaceLandmarks[0]){
              const L=r.multiFaceLandmarks[0];
              const mean=(idxs)=>idxs.reduce((S,i)=>({x:S.x+L[i].x*img.width,y:S.y+L[i].y*img.height}),{x:0,y:0});
              const rightIdx=[468,469,470,471,472], leftIdx=[473,474,475,476,477];
              const Rm=mean(rightIdx); const Lm=mean(leftIdx);
              const R={x:Rm.x/rightIdx.length,y:Rm.y/rightIdx.length};
              const Lp={x:Lm.x/leftIdx.length,y:Lm.y/leftIdx.length};
              // guardar centro rostro para overlay
              const cX=(R.x+Lp.x)/2, cY=(R.y+Lp.y)/2; lastFaceCenter.current={x:cX,y:cY};
              resolve({R, L: Lp, method:'MediaPipe'});
            }else{
              const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
              resolve({R:{x:cx+d/2,y:cy}, L:{x:cx-d/2,y:cy}, method:'Estimaci√≥n'});
            }
          });
          faceMesh.send({image:c});
        }else{
          const cx=img.width/2, cy=img.height*0.45, d=img.width*0.15;
          resolve({R:{x:cx+d/2,y:cy}, L:{x:cx-d/2,y:cy}, method:'Estimaci√≥n'});
        }
      });

      const lm=await getLm();
      const dx=lm.R.x-lm.L.x, dy=lm.R.y-lm.L.y;
      const ipd = Math.hypot(dx,dy)/pxPerMm;
      const ipd10 = Math.round(ipd*10)/10;

      // anotada
      const out=document.createElement('canvas'); out.width=img.width; out.height=img.height;
      const a=out.getContext('2d'); a.drawImage(img,0,0);
      a.fillStyle='#ef4444';
      a.beginPath(); a.arc(lm.L.x,lm.L.y,12,0,Math.PI*2); a.fill();
      a.beginPath(); a.arc(lm.R.x,lm.R.y,12,0,Math.PI*2); a.fill();
      a.strokeStyle='#ef4444'; a.lineWidth=5; a.beginPath(); a.moveTo(lm.L.x,lm.L.y); a.lineTo(lm.R.x,lm.R.y); a.stroke();
      a.font='700 28px system-ui,-apple-system'; a.fillStyle='#fff'; a.strokeStyle='#000'; a.lineWidth=6;
      const mx=(lm.L.x+lm.R.x)/2, my=(lm.L.y+lm.R.y)/2-24;
      a.strokeText(`IPD: ${ipd10} mm`,mx-90,my); a.fillText(`IPD: ${ipd10} mm`,mx-90,my);
      setAnnotated(out.toDataURL('image/png'));
    }catch(e){ setErr('No se pudo procesar: '+(e.message||e)); }
  };

  return (
    <div className="min-h-screen p-4">
      <div className="max-w-3xl mx-auto space-y-4">
        <header className="bg-white rounded-2xl shadow p-5 border-t-4 border-indigo-500">
          <div className="flex items-center justify-between gap-3">
            <div>
              <h1 className="text-3xl font-bold">Medidor √ìptico Facial</h1>
              <p className="text-slate-600">Gu√≠a CR80 + OpenCV/MediaPipe</p>
            </div>
            <div className="flex gap-2 text-xs">
              <span className="px-2 py-1 rounded bg-slate-100">secure: <b className="tag">{location.protocol==='https:'?'true':'false'}</b></span>
              <span className="px-2 py-1 rounded bg-slate-100">opencv: <b className="tag">{ocvReady?'ready':'loading'}</b></span>
              <span className="px-2 py-1 rounded bg-slate-100">estado: <b className="tag">{state}</b></span>
            </div>
          </div>
        </header>

        <section className="bg-white rounded-2xl shadow p-5">
          <h2 className="text-xl font-semibold mb-3">Captura de Imagen</h2>

          <div className="grid grid-cols-3 gap-3 mb-3">
            <label className="flex items-center justify-center gap-2 bg-slate-800 text-white rounded-xl py-3 cursor-pointer">
              üñºÔ∏è <span>Subir Foto</span>
              <input type="file" accept="image/*" className="hidden"
                     onChange={e=>{
                       const f=e.target.files?.[0]; if(!f) return;
                       const rd=new FileReader(); rd.onload=ev=>{ setImage(ev.target.result); setAnnotated(null); if(autoProcess) process(ev.target.result); };
                       rd.readAsDataURL(f);
                     }}/>
            </label>
            <button onClick={startCam} className="bg-violet-600 hover:bg-violet-700 text-white rounded-xl py-3">üì∑ C√°mara</button>
            <button onClick={stopCam} className="bg-rose-600 hover:bg-rose-700 text-white rounded-xl py-3">üî¥ Cerrar</button>
          </div>

          {err && <div className="bg-red-50 text-red-800 border border-red-200 rounded-xl p-3 mb-3">{err}</div>}

          <div className="viewer">
            <video ref={vidRef} className="cam" autoplay playsinline muted></video>
            <canvas ref={overlayRef} className="overlay"></canvas>
            {cameraOn && <button className="capture-fab" onClick={()=>capture(false)} aria-label="Capturar">üì∏</button>}
          </div>

          <div className="mt-3 flex flex-wrap items-center gap-3">
            <label className="inline-flex items-center gap-2">
              <input type="checkbox" className="scale-110" checked={useGuide} onChange={e=>setUseGuide(e.target.checked)}/>
              <span>Usar Gu√≠a CR80</span>
            </label>
            <label className="inline-flex items-center gap-2">
              <input type="checkbox" className="scale-110" checked={autoCapture} onChange={e=>setAutoCapture(e.target.checked)}/>
              <span>Auto-capturar (‚â•{Math.round(autoThreshold*100)}%)</span>
            </label>
            <label className="inline-flex items-center gap-2">
              <input type="checkbox" className="scale-110" checked={autoProcess} onChange={e=>setAutoProcess(e.target.checked)}/>
              <span>Procesar al capturar</span>
            </label>
            <div className="ml-auto text-sm text-slate-600">
              score: <b className="tag">{Math.round(scorePct*100)}%</b>
            </div>
          </div>

          <div className="mt-4">
            <div className="text-sm text-slate-700 mb-1">Ajuste fino escala (¬±10%) ¬∑ actual: <b className="tag">{fineAdj}%</b></div>
            <input type="range" min="-10" max="10" step="1" value={fineAdj} onChange={e=>setFineAdj(parseInt(e.target.value))} className="w-full"/>
            <div className="text-xs text-slate-500 mt-1">Escala efectiva: <b className="tag">{pxPerMm.toFixed(3)}</b> px/mm ‚Ä¢ Gu√≠a: <b className="tag">{guidePx}px</b> (alto {Math.round(guidePx/CR80_AR)}px)</div>
          </div>
        </section>

        {image && !autoProcess && (
          <section className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Imagen capturada</h3>
            <img src={image} className="w-full rounded-lg shadow" alt="captura"/>
            <div className="mt-3">
              <button onClick={()=>process()} className="bg-blue-600 hover:bg-blue-700 text-white rounded-xl py-2 px-4">Procesar</button>
            </div>
          </section>
        )}

        {annotated && (
          <section className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Resultado</h3>
            <img src={annotated} className="w-full rounded-lg shadow" alt="resultado"/>
            <a className="inline-block mt-3 px-3 py-2 rounded bg-indigo-600 text-white" download="resultado.png" href={annotated}>Descargar PNG</a>
          </section>
        )}

        <footer className="text-center text-xs text-slate-500 py-6">¬© 2025 ‚Äî CR80 + OpenCV + MediaPipe</footer>
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>